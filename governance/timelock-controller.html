<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Timelock Controller - The Documentation of Metis</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../use-component.html"><strong aria-hidden="true">2.</strong> Use Component</a></li><li class="chapter-item expanded "><a href="../access-control.html"><strong aria-hidden="true">3.</strong> Access Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../access-control/ownable.html"><strong aria-hidden="true">3.1.</strong> Ownable</a></li><li class="chapter-item expanded "><a href="../access-control/access-control.html"><strong aria-hidden="true">3.2.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="../access-control/access-control-enumerable.html"><strong aria-hidden="true">3.3.</strong> Access Control Enumerable</a></li></ol></li><li class="chapter-item expanded "><a href="../governance.html"><strong aria-hidden="true">4.</strong> Governance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../governance/timelock-controller.html" class="active"><strong aria-hidden="true">4.1.</strong> Timelock Controller</a></li></ol></li><li class="chapter-item expanded "><a href="../tokens.html"><strong aria-hidden="true">5.</strong> Tokens</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tokens/erc20.html"><strong aria-hidden="true">5.1.</strong> ERC20</a></li><li class="chapter-item expanded "><a href="../tokens/erc721.html"><strong aria-hidden="true">5.2.</strong> ERC721</a></li><li class="chapter-item expanded "><a href="../tokens/erc777.html"><strong aria-hidden="true">5.3.</strong> ERC777</a></li><li class="chapter-item expanded "><a href="../tokens/erc1155.html"><strong aria-hidden="true">5.4.</strong> ERC1155</a></li></ol></li><li class="chapter-item expanded "><a href="../utilities.html"><strong aria-hidden="true">6.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../utilities/escrow.html"><strong aria-hidden="true">6.1.</strong> Escrow</a></li></ol></li><li class="chapter-item expanded "><a href="../security.html"><strong aria-hidden="true">7.</strong> Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../security/pausable.html"><strong aria-hidden="true">7.1.</strong> Pausable</a></li><li class="chapter-item expanded "><a href="../security/reentrancy-guard.html"><strong aria-hidden="true">7.2.</strong> Reentrancy Guard</a></li></ol></li><li class="chapter-item expanded "><a href="../tools.html"><strong aria-hidden="true">8.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/erc165.html"><strong aria-hidden="true">8.1.</strong> ERC165</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Documentation of Metis</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="timelock-controller"><a class="header" href="#timelock-controller">Timelock Controller</a></h1>
<p>Contract module which acts as a timelocked controller. When set as the
owner of an <code>Ownable</code> smart contract, it enforces a timelock on all
<code>enuser_caller_owner</code> maintenance operations. This gives time for users of the
controlled contract to exit before a potentially dangerous maintenance
operation is applied.</p>
<p>By default, this contract is self administered, meaning administration tasks
have to go through the timelock process. The proposer (resp executor) role
is in charge of proposing (resp executing) operations. A common use case is
to position this <code>TimelockController</code> as the owner of a smart contract, with
a multisig or a DAO as the sole proposer.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To make a timelock controller contract, we should import timelock_controller at first.</p>
<p>Note the <code>timelock_controller</code> component is based on <code>access_control</code> component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    use access_control::RoleId;
    use ink_prelude::vec::Vec;
    use metis_access_control as access_control;
    use metis_lang::{
        import,
        metis,
    };
    use metis_timelock_controller as timelock_controller;
    pub use metis_timelock_controller::{
        Error,
        Result,
    };

    #[ink(storage)]
    #[import(timelock_controller, access_control)]
    pub struct TimelockController {
        timelock_controller: timelock_controller::Data&lt;TimelockController&gt;,
        access_control: access_control::Data&lt;TimelockController&gt;,
    }

    // other logic for
}
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    impl timelock_controller::Impl&lt;TimelockController&gt; for TimelockController {}
<span class="boring">}
</span></code></pre></pre>
<p>Then add the event for timelock_controller, we add the events for the <code>access_control</code> component also:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when a call is scheduled as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallScheduled {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
        pub predecessor: Option&lt;[u8; 32]&gt;,
        pub delay: Timestamp,
    }

    /// Emitted when a call is performed as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallExecuted {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
    }

    /// Emitted when operation `id` is cancelled.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct Cancelled {
        #[ink(topic)]
        pub id: [u8; 32],
    }

    /// Emitted when the minimum delay for future operations is modified.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct MinDelayChange {
        pub old_duration: Timestamp,
        pub new_duration: Timestamp,
    }

    /// Emitted when `new_admin_role` is set as ``role``'s
    /// admin role, replacing `previous_admin_role`
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleAdminChanged {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub previous_admin_role: Option&lt;RoleId&gt;,
        #[ink(topic)]
        pub new_admin_role: RoleId,
    }

    /// Emitted when `account` is granted `role`.
    ///
    /// `sender` is the account that originated the contract call,
    /// an admin role bearer except when using {_setupRole}.
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleGranted {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }

    /// Emitted when `account` is revoked `role`.
    ///
    /// `sender` is the account that originated the contract call:
    ///   - if using `revoke_role`, it is the admin role bearer
    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleRevoked {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl TimelockController {
        #[ink(constructor)]
        pub fn new(
            min_delay: Timestamp,
            proposers: Vec&lt;AccountId&gt;,
            executors: Vec&lt;AccountId&gt;,
        ) -&gt; Self {
            let mut instance = Self {
                timelock_controller: timelock_controller::Data::new(),
                access_control: access_control::Data::new(),
            };

            timelock_controller::Impl::init(
                &amp;mut instance,
                min_delay,
                proposers,
                executors,
            );
            instance
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the messages for contract.</p>
<blockquote>
<p>NOTE: the <code>execute</code> message should be <code>payable</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl TimelockController{
        /// Returns `true` if `account` has been granted `role`.
        #[ink(message)]
        pub fn has_role(&amp;self, role: RoleId, account: AccountId) -&gt; bool {
            access_control::Impl::has_role(self, role, account)
        }

        /// @dev Returns the admin role that controls `role`. See {grant_role} and
        /// {revoke_role}.
        ///
        /// To change a role's admin, use {_setRoleAdmin}.
        #[ink(message)]
        pub fn get_role_admin(&amp;self, role: RoleId) -&gt; Option&lt;RoleId&gt; {
            access_control::Impl::get_role_admin(self, role)
        }

        /// @dev Grants `role` to `account`.
        ///
        /// If `account` had not been already granted `role`, emits a {RoleGranted}
        /// event.
        ///
        /// Requirements:
        ///
        /// - the caller must have ``role``'s admin role.
        #[ink(message)]
        pub fn grant_role(&amp;mut self, role: RoleId, account: AccountId) {
            access_control::Impl::grant_role(self, role, account)
        }

        /// @dev Revokes `role` from `account`.
        ///
        /// If `account` had been granted `role`, emits a {RoleRevoked} event.
        ///
        /// Requirements:
        ///
        /// - the caller must have ``role``'s admin role.
        #[ink(message)]
        pub fn revoke_role(&amp;mut self, role: RoleId, account: AccountId) {
            access_control::Impl::revoke_role(self, role, account)
        }

        /// @dev Revokes `role` from the calling account.
        ///
        /// Roles are often managed via {grant_role} and {revoke_role}: this function's
        /// purpose is to provide a mechanism for accounts to lose their privileges
        /// if they are compromised (such as when a trusted device is misplaced).
        ///
        /// If the calling account had been granted `role`, emits a {RoleRevoked}
        /// event.
        ///
        /// Requirements:
        ///
        /// - the caller must be `account`.
        #[ink(message)]
        pub fn renounce_role(&amp;mut self, role: RoleId, account: AccountId) {
            access_control::Impl::renounce_role(self, role, account)
        }

        /// Returns whether an id correspond to a registered operation. This
        /// includes both Pending, Ready and Done operations.
        #[ink(message)]
        pub fn is_operation(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation(self, &amp;id)
        }

        /// Returns whether an operation is pending or not.
        #[ink(message)]
        pub fn is_operation_pending(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation_pending(self, &amp;id)
        }

        /// Returns whether an operation is ready or not.
        #[ink(message)]
        pub fn is_operation_ready(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation_ready(self, &amp;id)
        }

        /// Returns whether an operation is done or not.
        #[ink(message)]
        pub fn is_operation_done(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation_done(self, &amp;id)
        }

        /// Returns the timestamp at with an operation becomes ready (0 for
        /// unset operations, 1 for done operations).
        #[ink(message)]
        pub fn get_timestamp(&amp;self, id: [u8; 32]) -&gt; Timestamp {
            timelock_controller::Impl::get_timestamp(self, &amp;id)
        }

        /// Returns the minimum delay for an operation to become valid.
        ///
        /// This value can be changed by executing an operation that calls `updateDelay`.
        #[ink(message)]
        pub fn get_min_delay(&amp;self) -&gt; Timestamp {
            timelock_controller::Impl::get_min_delay(self)
        }

        /// Returns the identifier of an operation containing a single
        /// transaction.
        #[ink(message)]
        pub fn hash_operation(
            &amp;self,
            target: AccountId,
            value: Balance,
            data: Vec&lt;u8&gt;,
            predecessor: Option&lt;[u8; 32]&gt;,
            salt: [u8; 32],
        ) -&gt; [u8; 32] {
            timelock_controller::Impl::hash_operation(
                self,
                &amp;target,
                &amp;value,
                &amp;data,
                &amp;predecessor,
                &amp;salt,
            )
        }

        /// Schedule an operation containing a single transaction.
        ///
        /// Emits a `CallScheduled` event.
        ///
        /// Requirements:
        ///
        /// - the caller must have the 'proposer' role.
        #[ink(message)]
        pub fn schedule(
            &amp;mut self,
            target: AccountId,
            value: Balance,
            data: Vec&lt;u8&gt;,
            predecessor: Option&lt;[u8; 32]&gt;,
            salt: [u8; 32],
            delay: Timestamp,
        ) {
            timelock_controller::Impl::schedule(
                self,
                target,
                value,
                data,
                predecessor,
                salt,
                delay,
            )
        }

        /// Cancel an operation.
        ///
        /// Requirements:
        ///
        /// - the caller must have the 'proposer' role.
        #[ink(message)]
        pub fn cancel(&amp;mut self, id: [u8; 32]) {
            timelock_controller::Impl::cancel(self, id)
        }

        /// Execute an (ready) operation containing a single transaction.
        ///
        /// Emits a `CallExecuted` event.
        ///
        /// Requirements:
        ///
        /// - the caller must have the 'executor' role.
        #[ink(message, payable)]
        pub fn execute(
            &amp;mut self,
            target: AccountId,
            value: Balance,
            data: Vec&lt;u8&gt;,
            predecessor: Option&lt;[u8; 32]&gt;,
            salt: [u8; 32],
        ) {
            timelock_controller::Impl::execute(
                self,
                target,
                value,
                data,
                predecessor,
                salt,
            )
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<p>the caller to call need impl the <code>on_call</code> message:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Receiver {
        #[ink(message, payable)]
        pub fn on_call(
            &amp;mut self,
            _operator: AccountId,
            _data: Vec&lt;u8&gt;,
        ) -&gt; bool {
            unimplemented!()
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>like this, NOTE the <code>on_call</code> should be payable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[ink(message, payable)]
        pub fn on_call(
            &amp;mut self,
            operator: AccountId,
            data: Vec&lt;u8&gt;,
        ) -&gt; bool {
            // value to transferred_balance
            let value = Self::env().transferred_balance();

            // emit events
            Self::env().emit_event(CallReceived {
                operator,
                value,
                data,
            });

            // if return false should be error.
            true
        }
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages-for-txs"><a class="header" href="#messages-for-txs">Messages for Txs</a></h2>
<h3 id="schedule"><a class="header" href="#schedule">schedule</a></h3>
<p>Schedule an operation containing a single transaction.</p>
<p>Emits a <code>CallScheduled</code> event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have the 'proposer' role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Schedule an operation containing a single transaction.
    ///
    /// Emits a `CallScheduled` event.
    ///
    /// Requirements:
    ///
    /// - the caller must have the 'proposer' role.
    fn schedule(
        &amp;mut self,
        target: E::AccountId,
        value: E::Balance,
        data: Vec&lt;u8&gt;,
        predecessor: Option&lt;[u8; 32]&gt;,
        salt: [u8; 32],
        delay: E::Timestamp,
    ) {
        access_control::Impl::ensure_caller_role(self, PROPOSER_ROLE);

        let id = self.hash_operation(&amp;target, &amp;value, &amp;data, &amp;predecessor, &amp;salt);

        self._schedule(id, delay);

        self.emit_event_call_scheduled(id, target, value, data, predecessor, delay);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="cancel"><a class="header" href="#cancel">cancel</a></h3>
<p>Cancel an operation.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have the 'proposer' role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Cancel an operation.
    ///
    /// Requirements:
    ///
    /// - the caller must have the 'proposer' role.
    fn cancel(&amp;mut self, id: [u8; 32]) {
        access_control::Impl::ensure_caller_role(self, PROPOSER_ROLE);

        assert!(
            self.is_operation_pending(&amp;id),
            &quot;TimelockController: operation cannot be cancelled&quot;
        );
        Storage::&lt;E, Data&lt;E&gt;&gt;::get_mut(self).timestamps.take(&amp;id);

        self.emit_event_cancelled(id);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="execute"><a class="header" href="#execute">execute</a></h3>
<p>Execute an (ready) operation containing a single transaction.</p>
<p>Emits a <code>CallExecuted</code> event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have the 'executor' role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Execute an (ready) operation containing a single transaction.
    ///
    /// Emits a `CallExecuted` event.
    ///
    /// Requirements:
    ///
    /// - the caller must have the 'executor' role.
    fn execute(
        &amp;mut self,
        target: E::AccountId,
        value: E::Balance,
        data: Vec&lt;u8&gt;,
        predecessor: Option&lt;[u8; 32]&gt;,
        salt: [u8; 32],
    ) {
        self.ensure_only_role_or_open_role(EXECUTOR_ROLE);

        let id = self.hash_operation(&amp;target, &amp;value, &amp;data, &amp;predecessor, &amp;salt);

        self._before_call(predecessor);
        self._call(id, target, value, data);
        self._after_call(id);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys"><a class="header" href="#message-for-querys">Message for Querys</a></h2>
<h3 id="is_operation"><a class="header" href="#is_operation">is_operation</a></h3>
<p>Returns whether an id correspond to a registered operation. This includes both Pending, Ready and Done operations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an id correspond to a registered operation. This
    /// includes both Pending, Ready and Done operations.
    fn is_operation(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        self.get_timestamp(id) &gt; E::Timestamp::from(0_u8)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operation_pending"><a class="header" href="#is_operation_pending">is_operation_pending</a></h3>
<p>Returns whether an operation is pending or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an operation is pending or not.
    fn is_operation_pending(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        self.get_timestamp(id) &gt; E::Timestamp::from(_DONE_TIMESTAMP)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operation_ready"><a class="header" href="#is_operation_ready">is_operation_ready</a></h3>
<p>Returns whether an operation is ready or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an operation is ready or not.
    fn is_operation_ready(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        let timestamp = self.get_timestamp(id);
        timestamp &gt; E::Timestamp::from(_DONE_TIMESTAMP)
            &amp;&amp; timestamp &lt;= Self::block_timestamp()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operation_done"><a class="header" href="#is_operation_done">is_operation_done</a></h3>
<p>Returns whether an operation is done or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an operation is done or not.
    fn is_operation_done(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        self.get_timestamp(id) == E::Timestamp::from(_DONE_TIMESTAMP)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_timestamp"><a class="header" href="#get_timestamp">get_timestamp</a></h3>
<p>Returns the timestamp at with an operation becomes ready (0 for unset operations, 1 for done operations).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the timestamp at with an operation becomes ready (0 for
    /// unset operations, 1 for done operations).
    fn get_timestamp(&amp;self, id: &amp;[u8; 32]) -&gt; E::Timestamp {
        *Storage::&lt;E, Data&lt;E&gt;&gt;::get(self)
            .timestamps
            .get(id)
            .unwrap_or(&amp;E::Timestamp::from(0_u8))
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_min_delay"><a class="header" href="#get_min_delay">get_min_delay</a></h3>
<p>Returns the minimum delay for an operation to become valid.</p>
<p>This value can be changed by executing an operation that calls <code>update_delay</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the minimum delay for an operation to become valid.
    ///
    /// This value can be changed by executing an operation that calls `update_delay`.
    fn get_min_delay(&amp;self) -&gt; E::Timestamp {
        *Storage::&lt;E, Data&lt;E&gt;&gt;::get(self).min_delay
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="hash_operation"><a class="header" href="#hash_operation">hash_operation</a></h3>
<p>Returns the identifier of an operation containing a single transaction.</p>
<blockquote>
<p>NOTE: This <code>hash = Blake2x256(target + value + data + predecessor + salt)</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the identifier of an operation containing a single
    /// transaction.
    fn hash_operation(
        &amp;self,
        target: &amp;E::AccountId,
        value: &amp;E::Balance,
        data: &amp;Vec&lt;u8&gt;,
        predecessor: &amp;Option&lt;[u8; 32]&gt;,
        salt: &amp;[u8; 32],
    ) -&gt; [u8; 32] {
        // for target + value + data + predecessor + salt
        let mut hash_data: Vec&lt;u8&gt; = Vec::with_capacity(128 + data.len());

        hash_data.append(&amp;mut target.encode());
        hash_data.append(&amp;mut value.encode());
        hash_data.append(&amp;mut data.clone());
        hash_data.append(&amp;mut predecessor.encode());
        for s in salt.into_iter() {
            hash_data.push(s.clone());
        }

        Self::hash_bytes::&lt;Blake2x256&gt;(&amp;hash_data)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis"><a class="header" href="#apis">Apis</a></h2>
<h3 id="ensure_only_role_or_open_role"><a class="header" href="#ensure_only_role_or_open_role">ensure_only_role_or_open_role</a></h3>
<p>To make a function callable only by a certain role. In
addition to checking the sender's role, <code>AccountId::default()</code> 's role is also
considered. Granting a role to <code>AccountId::default()</code> is equivalent to enabling
this role for everyone.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// To make a function callable only by a certain role. In
    /// addition to checking the sender's role, `address(0)` 's role is also
    /// considered. Granting a role to `address(0)` is equivalent to enabling
    /// this role for everyone.
    fn ensure_only_role_or_open_role(&amp;self, role: RoleId) {
        if !access_control::Impl::has_role(self, role, E::AccountId::default()) {
            access_control::Impl::ensure_caller_role(self, role);
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="callscheduled"><a class="header" href="#callscheduled">CallScheduled</a></h3>
<p>Emitted when a call is scheduled as part of operation <code>id</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when a call is scheduled as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallScheduled {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
        pub predecessor: Option&lt;[u8; 32]&gt;,
        pub delay: Timestamp,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="callexecuted"><a class="header" href="#callexecuted">CallExecuted</a></h3>
<p>Emitted when a call is performed as part of operation <code>id</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when a call is performed as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallExecuted {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="cancelled"><a class="header" href="#cancelled">Cancelled</a></h3>
<p>Emitted when operation <code>id</code> is cancelled.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when operation `id` is cancelled.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct Cancelled {
        #[ink(topic)]
        pub id: [u8; 32],
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="mindelaychange"><a class="header" href="#mindelaychange">MinDelayChange</a></h3>
<p>Emitted when the minimum delay for future operations is modified.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when the minimum delay for future operations is modified.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct MinDelayChange {
        pub old_duration: Timestamp,
        pub new_duration: Timestamp,
    }
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../governance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../tokens.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../governance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../tokens.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
