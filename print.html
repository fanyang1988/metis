<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Documentation of Metis</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="use-component.html"><strong aria-hidden="true">2.</strong> Use Component</a></li><li class="chapter-item expanded "><a href="access-control.html"><strong aria-hidden="true">3.</strong> Access Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="access-control/ownable.html"><strong aria-hidden="true">3.1.</strong> Ownable</a></li><li class="chapter-item expanded "><a href="access-control/access-control.html"><strong aria-hidden="true">3.2.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="access-control/access-control-enumerable.html"><strong aria-hidden="true">3.3.</strong> Access Control Enumerable</a></li></ol></li><li class="chapter-item expanded "><a href="governance.html"><strong aria-hidden="true">4.</strong> Governance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="governance/timelock-controller.html"><strong aria-hidden="true">4.1.</strong> Timelock Controller</a></li></ol></li><li class="chapter-item expanded "><a href="tokens.html"><strong aria-hidden="true">5.</strong> Tokens</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tokens/erc20.html"><strong aria-hidden="true">5.1.</strong> ERC20</a></li><li class="chapter-item expanded "><a href="tokens/erc721.html"><strong aria-hidden="true">5.2.</strong> ERC721</a></li><li class="chapter-item expanded "><a href="tokens/erc777.html"><strong aria-hidden="true">5.3.</strong> ERC777</a></li><li class="chapter-item expanded "><a href="tokens/erc1155.html"><strong aria-hidden="true">5.4.</strong> ERC1155</a></li></ol></li><li class="chapter-item expanded "><a href="utilities.html"><strong aria-hidden="true">6.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="utilities/escrow.html"><strong aria-hidden="true">6.1.</strong> Escrow</a></li></ol></li><li class="chapter-item expanded "><a href="security.html"><strong aria-hidden="true">7.</strong> Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="security/pausable.html"><strong aria-hidden="true">7.1.</strong> Pausable</a></li><li class="chapter-item expanded "><a href="security/reentrancy-guard.html"><strong aria-hidden="true">7.2.</strong> Reentrancy Guard</a></li></ol></li><li class="chapter-item expanded "><a href="tools.html"><strong aria-hidden="true">8.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tools/erc165.html"><strong aria-hidden="true">8.1.</strong> ERC165</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Documentation of Metis</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><a href="https://github.com/patractlabs/metis">Metis</a> will be the Wasm contract standard library developed by Patract Labs. Patract Labs will work with community forces to formulate various Wasm contract standards, develop corresponding implementations of ink! and Ask! versions, and conduct audits by professional institutions.</p>
<h2 id="0-motivation"><a class="header" href="#0-motivation">0. Motivation</a></h2>
<p>We believe that in the Wasm contract ecosystem, a development library similar to Openzeppelin-contracts is very necessary. This is Metis. For the sake of simplicity and readability, the patterns and meta-language provided by this library should be as consistent with Openzeppelin-contracts as possible, so as to reduce the burden on developers and effectively absorb the experience accumulated in the Solidity ecosystem.</p>
<p>But you need to realize that the Wasm contract development based on ink! and Ask! is very different from the EVM contract development based on Solidity. Wasm's mature system support allows developers to use a variety of different languages and tools to develop smart contracts. Based on these mature or rapid iteration platforms, developers can enjoy a large number of underlying facilities support and development experience accumulation, but different languages and tools often have different considerations and trade-offs. This means that developers will use completely different codes to express the same mechanism and design, which will bring huge communication costs and mental burdens to the community.</p>
<p>Faced with such problems, we need to summarize and accumulate the implementation model in the development of smart contracts. This idea was introduced in the book &quot;Implementation Patterns&quot; by Kent Beck. The purpose of summarizing the implementation mode is to clearly and accurately express the developer's intentions and ideas through these clear patterns, so that &quot;code that others can understand&quot; can be implemented. In contract development, this idea is very important.</p>
<p>From Openzeppelin-contracts, we can see that it summarizes several implementation models in the development of smart contracts, such as the &quot;contract expansion model&quot; based on the Solidity inheritance grammar. These implementation models are valuable experience accumulated in the Solidity ecology. Of course, different languages have different ways of practicing these modes. Metis will implement these modes and provide corresponding support on different platforms. For example, in Rust, it is obvious that you cannot directly use inheritance to implement contract expansion. For this, Metis will provide code implementation examples and provide a series of help libraries to reduce the developer's mental cost.</p>
<p>Metis will be more than just a Wasm contract standard library. We hope that through the practice of Metis, we can fully inherit and absorb previous contract development experience while exploring the best practices of Wasm contract development.</p>
<h2 id="1-problem"><a class="header" href="#1-problem">1. Problem</a></h2>
<p>At present, contract-based developers mainly face the following problems:</p>
<ul>
<li>Lack of reliable implementation of common contracts (such as ERC20)</li>
<li>It is difficult to achieve contract combination and expansion similar to the Solidity inheritance mechanism</li>
<li>Lack of a series of reliable public components to implement contracts</li>
<li>Lack of experience accumulation and model summary based on ink! development contracts</li>
</ul>
<p>The above problems severely limit the current ink!-based contract development ecology. Metis will solve these problems while avoiding the existing problems in Solidity.</p>
<h2 id="2-contract-standard-library"><a class="header" href="#2-contract-standard-library">2. Contract Standard Library</a></h2>
<p>Metis will implement a series of common components, similar to the Openzeppelin-contracts development library. These components will be thoroughly tested and code audited. These components will be as consistent as possible with Openzeppelin-contracts, which can reduce the burden on developers and effectively absorb the experience accumulated in the Solidity ecosystem.</p>
<p>Metis will include the following components:</p>
<ul>
<li>Openzeppelin-contracts-like components, including basic Access and Security components, as well as Token and Governance components</li>
<li>Component developed for ink! contracts, wasm-based contracts can support better abstraction mechanisms, and we can implement more complex and practical components</li>
<li>Summarizing abstract components from mature contract projects, metis will absorb the experience and accumulation of the community, including both the mature Solidity ecology and emerging blockchain contract projects.</li>
<li>The expansion of ink! contracts, including basic data structures for different scenarios, etc.</li>
</ul>
<p>In the previous version of Metis, we will first implement Openzeppelin-contracts-like components for developers to use. These components include:</p>
<ul>
<li>Token: ERC20, ERC721, ERC777, ERC1155 and the expansion contract of the above Token contract</li>
<li>Access: Ownable, AccessControl, TimelockController</li>
<li>Security: PullPayment, ReentrancyGuard, Pausable</li>
</ul>
<h2 id="3-ink-component"><a class="header" href="#3-ink-component">3. ink! component</a></h2>
<p>Most of Metis development libraries are composed of contract components. In Solidity, the introduction of contract components can be implemented based on inheritance. Generally, the contract components will include the following parts:</p>
<ul>
<li>Component Storage: The storage state related to the logic of the component itself, these states do not need to be exposed to the outside</li>
<li>Component Message: The externally-facing Message of the component</li>
<li>Component Event: The event that the component's own logic will  emit</li>
<li>Component internal interface: an interface for other logic in the contract to call</li>
</ul>
<p>For example, common Ownable contracts:</p>
<pre><code class="language-Solidity">abstract contract Ownable is Context {
    // Component Storage
    address private _owner;

    // Component Event
    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );
    
    // Component internal interface
    modifier onlyOwner() {
        ...
    }

    // Component Event
    function renounceOwnership() public virtual onlyOwner {
        ...
    }

    ...
}
</code></pre>
<p>If a contract needs to be Ownable, just inherit the contract:</p>
<pre><code class="language-Solidity">contract Escrow is Ownable {
...
}
</code></pre>
<p>Similarly, other components can also have Ownable through inheritance:</p>
<pre><code class="language-Solidity">contract Pausable is Ownable {
  ...
  function unpause() public onlyOwner whenPaused {
      ...
  }
}
</code></pre>
<p>The intention of inheritance here is actually composition rather than an <code>is-a</code> relationship. Although excessive use of inheritance in Solidity will cause many problems, inheritance for specific intentions is still an important way to achieve it.</p>
<p>In contract development based on ink!, through metis, we can also achieve the same motivation based on generics and traits:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>...

#[metis::contract] // metis contract macro, will use ink_lang::contract auto
mod flipper {
    ...

    #[ink(storage)]
    #[import(ownable)] // flipper import the ownable
    pub struct Flipper {
        ownable: ownable::Data&lt;Flipper&gt;, // data by ownable

        value: bool,
    }

    #[ink(event)]
    #[metis(ownable)] // event in ink! will refactor
    pub struct OwnershipTransferred {
        //...
    }

    impl Flipper {
        //...

        #[ink(message)]
        pub fn flip(&amp;mut self) {
            // check owner
            ownable::Impl::ensure_caller_is_owner(self);

            self.value = !self.value;
        }

        //...

        #[ink(message)]
        pub fn renounce_ownership(&amp;mut self) {
            ownable::Impl::renounce_ownership(self) // owner message
        }

        //...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Metis assists developers to achieve the same function through a series of helper macros. In order to improve the auditability of the contract, here we hope that users clearly implement storage, event and message declarations.</p>
<p>At the same time, metis has improved the implementation of components:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//...

// Storage
#[metis::component::storage]
pub struct Data&lt;E&gt;
where
    E: Env,
{
    owner: Lazy&lt;Option&lt;E::AccountId&gt;&gt;,
}

// Event trait
pub trait EventEmit&lt;E: Env&gt;: EnvAccess&lt;E&gt; {
    //...
}

// Impl trait
pub trait Impl&lt;E: Env&gt;: Storage&lt;E&gt; + EventEmit&lt;E&gt; {
    // logics
    fn init(&amp;mut self) {
        self.get_mut().set_ownership(&amp;Some(Self::caller()));
    }

    fn renounce_ownership(&amp;mut self) {
        self.ensure_caller_is_owner();

        self.emit_event_ownership_transferred(
            self.get().get_ownership().clone(),
            None);

        self.get_mut().set_ownership(&amp;None);
    }

    //...

    /// Panic if `owner` is not an owner
    fn ensure_owner(&amp;self, owner: &amp;E::AccountId) {
        assert!(&amp;self.get().get_ownership().clone().unwrap() == owner);
    }

    //...
}

<span class="boring">}
</span></code></pre></pre>
<p>Such components can extend their functions by inheriting other components, such as an ERC20 component with the function of destroying tokens:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Impl&lt;E&gt;: erc20::Impl&lt;E&gt;
where
    E: Env,
{
    fn _burn(&amp;mut self, account: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        //...
    }

    fn burn(&amp;mut self, amount: E::Balance) -&gt; Result&lt;()&gt; {
        self._burn(&amp;Self::caller(), amount)
    }

    fn burn_from(&amp;mut self, account: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        //...
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Based on metis, we can implement various contract combination modes implemented by Solidity through inheritance under limited intent, and at the same time, with the help of rust's zero-cost abstraction, these abstractions will not bring additional performance consumption.</p>
<h2 id="4-overall-roadmap"><a class="header" href="#4-overall-roadmap">4. Overall Roadmap</a></h2>
<p>Metis for ink! is divided into several milestones:</p>
<ul>
<li><strong>[M1]</strong> Implement basic component macros and components, improve component testing support, developers can build regular DAPPs based on Metis</li>
<li><strong>[M2]</strong> Complete component macros, complete component development support, developers can build custom components. Complete the api support corresponding to the metis component.</li>
<li><strong>[M3]</strong> Rich component library, complete component and API support for governance and financial mechanism, perfect mathematical library suitable for contract development to support DeFi-type contracts that require complex calculations.</li>
</ul>
<p>Considering that the current ink! and contract-pallet are still in iteration, some metis features will be implemented based on subsequent improvements, including:</p>
<ul>
<li>Contract proxy and upgradeable support will depend on the improvement of subsequent contract calls, by <a href="https://github.com/paritytech/ink/issues/739">739</a>.</li>
<li>The Event in the component, the Event in the current ink! cannot be independent of the contract, by <a href="https://github.com/paritytech/ink/issues/759">759</a>, the event in the current component is only an early implementation, and it will be refactored based on the improvement of ink! in the future.</li>
</ul>
<p>With the richness and completeness of the ink! contract community, metis will further implement more public components and libraries to assist developers in developing large-scale contract projects. Therefore, we may arrange [MR] milestones. It will be developed based on the iterative schedule of ink!</p>
<p><strong>[MR]</strong> According to the ink!'s iterative progress, community feedback, contract upgrades, contract proxy and cross-contract call support, refactor Event-related implementations, improve basic components and add development assistance macros to reduce duplication while ensuring auditability Code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-component"><a class="header" href="#use-component">Use Component</a></h1>
<h2 id="metis-mcci-architecture"><a class="header" href="#metis-mcci-architecture">Metis-MCCI architecture</a></h2>
<ul>
<li><code>M</code> : Data model. Most contracts read and write contract world states. These states map to data models, each associated with only one component.</li>
<li><code>C</code> : component. A component is a reusable, independent implementation unit that encapsulates data and methods and maintains orthogonality with other components.</li>
<li><code>C</code> : controller. The controller coordinates the components and implements the contract interface.</li>
<li><code>I</code> : interface. The interface is the user interface of the contract. The interface defines the behavior of the contract and, to some extent, defines metadata.</li>
</ul>
<pre><code class="language-txt">┌───────┐          ┌───────────────┬────────────────────────────────┐
│       │          │ Interface     │ Control                        │
│       │          │               │  ┌─────────────────────┐       │
│       │          │  Constructor  │  │ Component           │       │
│ User  │  Call    │               │  │ ┌───────────────────┴──┐    │
│       ├─────────►│  Messages     │  │ │ Component            │    │
│       │          │               │  │ │ ┌────────────────────┴─┐  │
│       │          │  Events       │  │ │ │ Component            │  │
├───────┤          │               │  │ │ │        ┌───────────┐ │  │
│       │  Call    │               │  │ │ │ Msgs   │           │ │  │
│       ├─────────►│               │  │ │ │        │ Module    │ │  │
│       │          │               │  │ │ │ Apis   │           │ │  │
│ Apps  │          │               │  │ │ │        │           │ │  │
│       │  Event   │               │  └─┤ │ Events └───────────┘ │  │
│       │◄─────────┤               │    └─┤                      │  │
│       │          │               │      └──────────────────────┘  │
│       │          │               │                                │
└───────┘          └───────────────┴────────────────────────────────┘
</code></pre>
<p>As shown in the figure, under the MCCI architecture, the contract is divided into a series of reusable components. The contract behavior is implent through the collaboration of components, and the contract behavior is clearly defined by interface and controller.</p>
<p>The contract's interface defines the contract's behavior, including:</p>
<ul>
<li>constructor</li>
<li>message</li>
<li>event</li>
</ul>
<p>The user of the contract interacts with the contract based on these three elements. In fact, these three elements also constitute ink! The main part of the contract metadata.</p>
<p>For a contract, these three things are guaranteed to be deterministic, unambiguous, and easy to understand. Therefore, the interface code of the contract code should be as cohesive as possible.</p>
<p>The contract controller is responsible for integrating the components. We break the main logic of the contract down into a series of reusable components, which can <strong>extend</strong> and <strong>compose</strong> based on other components.</p>
<p>A data model is the encapsulation of the state of a contract. A component of a contract needs a contract to meet the requirements of its data model. For a contract, its state will be represented as a combination of a series of data models.</p>
<p>In generally, the data model can also be considered as part of the contract behavior, and thus as part of the contract interface, but in most scenarios, external applications and users can not directly use the state of the chain, so the external encapsulation of the data model is not emphasized here.</p>
<h2 id="inheritance-vs-composition"><a class="header" href="#inheritance-vs-composition">Inheritance Vs Composition</a></h2>
<p>In contract development, we focus more on auditability of contracts, and the use of inheritance in solidity contract development will increase the difficulty of contract audit: The behavior logic of the contract is spread out in multiple files, even in different projects. Therefore, in Metis, we do not inherit the interface and implementation of the contract. The components and data model are introduced into the contract in a combined way.</p>
<p>Each component impl a series of functions, include the impl of messages and apis. Components can <strong>extend</strong> and <strong>compose</strong> based on other components.</p>
<p>For most of components, will like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The `EventEmit` impl the event emit api for ownable component.
pub trait EventEmit&lt;E: Env&gt;: EnvAccess&lt;E&gt; {
    /// Emit OwnershipTransferred event
    fn emit_event_ownership_transferred(
        &amp;mut self,
        previous_owner: Option&lt;E::AccountId&gt;,
        new_owner: Option&lt;E::AccountId&gt;,
    );
}

/// The `Impl` define ownable component impl funcs
pub trait Impl&lt;E: Env&gt;: Storage&lt;E, Data&lt;E&gt;&gt; + EventEmit&lt;E&gt; {
    /// init Initializes the contract setting the deployer as the initial owner.
    fn init(&amp;mut self) {
        // logic
    }

    /// Message impl 
    fn one_message_impl(&amp;mut self) -&gt; Result&lt;()&gt; {
        // msg impl which will call by ```xxx::Impl::one_message_impl(self)```

        // use the hook
        self.hook(xxx)?

        Ok(())
    }

    /// Message for Query impl
    fn one_query_impl(&amp; self, param_acc: &amp;E::AccountId) -&gt; Data {
        Data::default()
    }

    /// API for other message
    fn check_xxx(&amp;self, owner: &amp;E::AccountId) {
    }

    // Hook which need impl by contract
    fn hook(&amp;mut self, params: &amp;E::Balance) -&gt; Result&lt;()&gt;;
}

<span class="boring">}
</span></code></pre></pre>
<p>Some component will contains a default implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a default impl, each contract which impl storage and event emitter can be component
impl&lt;E: Env, T: Storage&lt;E, Data&lt;E&gt;&gt; + EventEmit&lt;E&gt;&gt; Impl&lt;E&gt; for T {}
<span class="boring">}
</span></code></pre></pre>
<p>To use this component, we can import this to contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>#[metis_lang::contract] // use `metis_lang::contract`
pub mod contract {
    // use the component: xxx1 and xxx2
    use metis_component_xxx1 as xxx1;
    use metis_component_xxx2 as xxx2;

    // use `import` and `metis` marco
    use metis_lang::{
        import,
        metis,
    };

    #[ink(storage)]
    #[import(xxx1, xxx2)] // import the component
    pub struct Contract {
        // add data to storage, which use Contract as Env to Data
        xxx1: xxx1::Data&lt;Contract&gt;,
        xxx2: xxx2::Data&lt;Contract&gt;,
    }

    /// add event for component
    /// in emit it will be emit_event_ownership_transferred
    #[ink(event)]
    #[metis(xxx1)] // event for xxx1
    pub struct OwnershipTransferred {
        /// previous owner account id
        #[ink(topic)]
        previous_owner: Option&lt;AccountId&gt;,
        /// new owner account id
        #[ink(topic)]
        new_owner: Option&lt;AccountId&gt;,
    }

    /// Event emitted when payee withdraw
    #[ink(event)]
    #[metis(xxx2)] // event for xxx1
    pub struct OtherEvent {
        #[ink(topic)]
        pub payee: AccountId,
        pub amount: Balance,
    }

    impl xxx1::Impl&lt;Contract&gt; for Contract {
        fn hook(
            &amp;mut self,
            params: &amp;E::Balance
        ) -&gt; Result&lt;()&gt; {
            // some logic

            Ok(())
        }
    }

    // impl
    impl Contract {
        #[ink(constructor)]
        pub fn new() -&gt; Self {
            // impl for default
            let mut instance = Self {
                xxx1: xxx1::Data::new(),
                xxx2: xxx2::Data::new(),
            };

            // init call
            xxx1::Impl::init(&amp;mut instance);
            xxx2::Impl::init(&amp;mut instance);

            // return instance
            instance
        }

        /// commits for one_message_impl
        #[ink(message)]
        pub fn one_message_impl(&amp;mut self) -&gt; Result&lt;()&gt; {
            // some other check
            xxx2::Impl::do_some_check(self);
            xxx1::Impl::one_message_impl(self)
        }

        /// commits for one_query_impl
        #[ink(message, payable)]
        pub fn one_query_impl(&amp;self, payee: AccountId) {
            xxx1::Impl::one_query_impl(self, payee)
        }

        /// commits for other_message_impl
        #[ink(message)]
        pub fn other_message_impl(&amp;mut self, payee: AccountId) {
            xxx1::Impl::check_xxx(self)
            // other logic
        }
    }

    #[cfg(test)]
    mod tests {
        // test for contract
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="hook-and-impl"><a class="header" href="#hook-and-impl">Hook and Impl</a></h2>
<p>In the last example, we can see the hook:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Hook which need impl by contract
    fn hook(&amp;mut self, params: &amp;E::Balance) -&gt; Result&lt;()&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>In some component, the hook has a default implementation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// @dev Hook that is called before any token transfer. This includes
    /// calls to {send}, {transfer}, {operatorSend}, minting and burning.
    ///
    /// Calling conditions:
    ///
    /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    /// will be to transferred to `to`.
    /// - when `from` is zero, `amount` tokens will be minted for `to`.
    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.
    /// - `from` and `to` are never both zero.
    ///
    /// To learn more about hooks,
    /// head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
    fn _before_token_transfer(
        &amp;mut self,
        _operator: &amp;E::AccountId,
        _from: &amp;Option&lt;&amp;E::AccountId&gt;,
        _to: &amp;Option&lt;&amp;E::AccountId&gt;,
        _amount: &amp;E::Balance,
    ) -&gt; Result&lt;()&gt; {
        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<p>The hook will call by component functions, user can define it, a normal example is Pausable ERC20 component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    fn before_token_transfer(
        &amp;mut self,
        _from: &amp;E::AccountId,
        _to: &amp;E::AccountId,
        _amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        metis_pausable::Impl::&lt;E&gt;::ensure_not_paused(self);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<p>The Pausable ERC20 component is extend the erc20 component, which implements the hook.</p>
<h2 id="metis-contract-component"><a class="header" href="#metis-contract-component">Metis Contract component</a></h2>
<p>In previous versions of Metis, we will first implement openZeppelin-contracts components for developers to use. These components include:</p>
<ul>
<li>Token: ERC20, ERC721, ERC777, ERC1155 and extensions of the above Token contracts</li>
<li>Access: Ownable, AccessControl, TimelockController</li>
<li>Security: PullPayment, ReentrancyGuard, Pausable</li>
</ul>
<p>Metis will implement a set of common components, similar to the OpenZeppelin-Contracts development library, which will be fully tested and code audited,
These components will be kept as consistent as possible with OpenZeppelin-contracts to reduce the developer's burden while effectively absorbing the experience of Solidity Ecology.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control"><a class="header" href="#access-control">Access Control</a></h1>
<p>The Access Control components provides a contract access mechanism.
These components are used to make contract permissions and limit contract cross-calling.</p>
<ul>
<li><a href="./access-control/ownable.html">Ownable</a></li>
<li><a href="./access-control/access-control.html">Access Control</a></li>
<li><a href="./access-control/access-control-enumerable.html">Access Control Enumerable</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownable"><a class="header" href="#ownable">Ownable</a></h1>
<p><code>Ownable</code> component which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions.</p>
<p>By default, the owner account will be the account which deploys the contract. This can later be changed with {transferOwnership}.</p>
<p>This components is used through inheritance. It will make available the func like <code>ensure_caller_is_owner</code>, which can be applied to your functions to restrict their use to the owner.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To use the <code>Ownable</code> component need, There is a example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    use metis_lang::{
        import,
        metis,
    };
    use metis_ownable as ownable;

    #[ink(storage)]
    #[import(ownable)]
    pub struct Contract {
        // ...
        ownable: ownable::Data&lt;Contract&gt;,
        // ...
    }

    // ...

    /// Event emitted when Owner AccountId Transferred
    #[ink(event)]
    #[metis(ownable)]
    pub struct OwnershipTransferred {
        /// previous owner account id
        #[ink(topic)]
        previous_owner: Option&lt;AccountId&gt;,
        /// new owner account id
        #[ink(topic)]
        new_owner: Option&lt;AccountId&gt;,
    }

    impl Contract {
        #[ink(constructor)]
        pub fn new() -&gt; Self {
            let mut instance = Self {
                // ...
                ownable: ownable::Data::new(),
                // ...
            };

            // ...

            ownable::Impl::init(&amp;mut instance);

            instance
        }

        /// Return the owner AccountId
        #[ink(message)]
        pub fn owner(&amp;self) -&gt; Option&lt;AccountId&gt; {
            *ownable::Impl::owner(self)
        }

        /// Leaves the contract without owner. It will not be possible to call
        /// `ensure_xxx` functions anymore. Can only be called by the current owner.
        /// NOTE: Renouncing ownership will leave the contract without an owner,
        /// thereby removing any functionality that is only available to the owner.
        #[ink(message)]
        pub fn renounce_ownership(&amp;mut self) {
            ownable::Impl::renounce_ownership(self)
        }

        /// Transfers ownership of the contract to a new account (`new_owner`).
        /// Can only be called by the current owner.
        #[ink(message)]
        pub fn transfer_ownership(&amp;mut self, new_owner: AccountId) {
            ownable::Impl::transfer_ownership(self, &amp;new_owner)
        }

        /// Example for owner
        #[ink(message)]
        pub fn msg_use_owner(&amp;mut self) {
            ownable::Impl::ensure_caller_is_owner(self);

            // other logics
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="module"><a class="header" href="#module">Module</a></h2>
<p><code>Ownable</code> components has one storage for the owner of the contract.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Data&lt;E&gt;
where
    E: Env,
{
    /// The owner of contract
    owner: Lazy&lt;Option&lt;E::AccountId&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>In constructor of contract, can use <code>init</code> to make the owner to caller:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[ink(constructor)]
        pub fn new() -&gt; Self {
            let mut instance = Self {
                // ...
                ownable: ownable::Data::new(),
                // ...
            };

            // ...
            ownable::Impl::init(&amp;mut instance);
            // ...

            instance
        }
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages-for-txs"><a class="header" href="#messages-for-txs">Messages for Txs</a></h2>
<p><code>Ownable</code> component use <code>transfer_ownership</code> and <code>renounce_ownership</code> to modify the owner of the contract.
all this need owner as caller.</p>
<h3 id="renounce_ownership"><a class="header" href="#renounce_ownership">renounce_ownership</a></h3>
<p><code>renounce_ownership</code> Leaves the contract without owner. It will not be possible to call <code>ensure_xxx</code> functions anymore. Can only be called by the current owner.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Leaves the contract without owner. It will not be possible to call
    /// `ensure_xxx` functions anymore. Can only be called by the current owner.
    /// NOTE: Renouncing ownership will leave the contract without an owner,
    /// thereby removing any functionality that is only available to the owner.
    #[ink(message)]
    pub fn renounce_ownership(&amp;mut self) {
        ownable::Impl::renounce_ownership(self)
    }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>NOTE</strong>: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.</p>
</blockquote>
<p><code>renounce_ownership</code> will emit <code>OwnershipTransferred</code> event by <code>new_owner</code> to <code>None</code>.</p>
<h3 id="transfer_ownership"><a class="header" href="#transfer_ownership">transfer_ownership</a></h3>
<p>Transfers ownership of the contract to a new account (<code>new_owner</code>). Can only be called by the current owner.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Transfers ownership of the contract to a new account (`new_owner`).
    /// Can only be called by the current owner.
    #[ink(message)]
    pub fn transfer_ownership(&amp;mut self, new_owner: AccountId) {
        ownable::Impl::transfer_ownership(self, &amp;new_owner)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys"><a class="header" href="#message-for-querys">Message for Querys</a></h2>
<h3 id="owner"><a class="header" href="#owner">owner</a></h3>
<p><code>owner</code> Return the owner AccountId.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Return the owner AccountId.
    #[ink(message)]
    pub fn owner(&amp;self) -&gt; Option&lt;AccountId&gt; {
        *ownable::Impl::owner(self)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>A contract with <code>Ownable</code> component can allow <code>owner</code> to be granted exclusive access to specific functions, this check need impl by <code>ensure_xxx</code> functions.</p>
<h3 id="ensure_owner"><a class="header" href="#ensure_owner">ensure_owner</a></h3>
<p><code>ensure_owner</code> check if <code>owner</code> is the owner of the contract, panic if the <code>owner</code> not the owner of the contract.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic if `owner` is not an owner
    fn ensure_owner(&amp;self, owner: &amp;E::AccountId) {
        assert!(&amp;self.get().get_ownership().clone().unwrap() == owner);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="ensure_caller_is_owner"><a class="header" href="#ensure_caller_is_owner">ensure_caller_is_owner</a></h3>
<p><code>ensure_caller_is_owner</code> check if caller is the owner of the contract, panic if the caller not the owner of the contract.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic if caller is not an owner
    fn ensure_caller_is_owner(&amp;self) {
        self.ensure_owner(&amp;Self::caller());
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="ensure_owner_renounce"><a class="header" href="#ensure_owner_renounce">ensure_owner_renounce</a></h3>
<p><code>ensure_owner_renounce</code> check the current owner is renounced.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic the contract owner is not renounced,
    fn ensure_owner_renounce(&amp;self) {
        assert!(self.get().get_ownership().is_none());
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="ownershiptransferred"><a class="header" href="#ownershiptransferred">OwnershipTransferred</a></h3>
<p>The Event will emit when the ownership of the contract is transferred:</p>
<ul>
<li>in constructor, will emit <code>None</code> -&gt; caller.</li>
<li>in <code>transfer_ownership</code>, will emit caller -&gt; new_owner.</li>
<li>in <code>renounce_ownership</code>, will emit caller -&gt; <code>None</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when Owner AccountId Transferred
    #[ink(event)]
    #[metis(ownable)]
    pub struct OwnershipTransferred {
        /// previous owner account id
        #[ink(topic)]
        previous_owner: Option&lt;AccountId&gt;,
        /// new owner account id
        #[ink(topic)]
        new_owner: Option&lt;AccountId&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control-1"><a class="header" href="#access-control-1">Access Control</a></h1>
<p>Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see <code>access-control-eunmerable</code>.</p>
<p>Roles are referred to by their <code>RoleId</code> which is a 32-bytes. These should be exposed in the external API and be unique. The best way to achieve this is by using hash digests.</p>
<p>Roles can be used to represent a set of permissions. To restrict access to a function call, use <code>ensure_caller_role</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // need role
    #[ink(message)]
    pub fn func(&amp;mut self) {
        access_control::Impl::ensure_caller_role(self, ROLE_ID_XXX);

        // other logics
    }
<span class="boring">}
</span></code></pre></pre>
<p>Roles can be granted and revoked dynamically via the <code>grant_role</code> and <code>revoke_role</code> functions. Each role has an associated admin role, and only accounts that have a role's admin role can call <code>grant_role</code> and <code>revoke_role</code>.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To use the Access Control Component, First is import the <code>access_control</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod example {
    pub use access_control::{
        Error,
        Result,
        RoleId,
    };
    use metis_access_control as access_control;
    use metis_lang::{
        import,
        metis,
    };

    #[ink(storage)]
    #[import(access_control)]
    pub struct Contract {
        access_control: access_control::Data&lt;Contract&gt;,

        // other modules
    }
<span class="boring">}
</span></code></pre></pre>
<p>Define the Event for access control:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `new_admin_role` is set as ``role``'s
    /// admin role, replacing `previous_admin_role`
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleAdminChanged {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub previous_admin_role: Option&lt;RoleId&gt;,
        #[ink(topic)]
        pub new_admin_role: RoleId,
    }

    /// Emitted when `account` is granted `role`.
    ///
    /// `sender` is the account that originated the contract call,
    /// an admin role bearer except when using {_setupRole}.
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleGranted {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }

    /// Emitted when `account` is revoked `role`.
    ///
    /// `sender` is the account that originated the contract call:
    ///   - if using `revoke_role`, it is the admin role bearer
    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleRevoked {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Impl the <code>constructor</code> of the contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[ink(constructor)]
    pub fn new(
        fliper: AccountId,
        setter: AccountId,
        admin: AccountId,
    ) -&gt; Self {
        let mut instance = Self {
            // Need add access_control module
            access_control: access_control::Data::new(),
        };

        // Use the `_setup_role` set the ROLEs
        access_control::Impl::_setup_role(&amp;mut instance, ROLE_ID_FLIPER, fliper);
        access_control::Impl::_setup_role(&amp;mut instance, ROLE_ID_SETTER, setter);
        access_control::Impl::_setup_role(&amp;mut instance, ROLE_ID_ADMIN, admin);

        // Use `_set_role_admin` set the role admin
        access_control::Impl::_set_role_admin(
            &amp;mut instance,
            ROLE_ID_FLIPER,
            ROLE_ID_ADMIN,
        );

        // create the default role
        instance
    }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>WARNNING: In metis, access control not have a <code>default admin role</code> which be admin role of all roles, so we need defined the role releations in constructor.</p>
</blockquote>
<p>In constructor, we can use <code>_setup_role</code> and <code>_set_role_admin</code> to set the role releations for contract.</p>
<p>Next, Add the message to control the role releations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns `true` if `account` has been granted `role`.
    #[ink(message)]
    pub fn has_role(&amp;self, role: RoleId, account: AccountId) -&gt; bool {
        access_control::Impl::has_role(self, role, account)
    }

    /// @dev Returns the admin role that controls `role`. See {grant_role} and
    /// {revoke_role}.
    ///
    /// To change a role's admin, use {_setRoleAdmin}.
    #[ink(message)]
    pub fn get_role_admin(&amp;self, role: RoleId) -&gt; Option&lt;RoleId&gt; {
        access_control::Impl::get_role_admin(self, role)
    }

    /// @dev Grants `role` to `account`.
    ///
    /// If `account` had not been already granted `role`, emits a {RoleGranted}
    /// event.
    ///
    /// Requirements:
    ///
    /// - the caller must have ``role``'s admin role.
    #[ink(message)]
    pub fn grant_role(&amp;mut self, role: RoleId, account: AccountId) {
        access_control::Impl::grant_role(self, role, account)
    }

    /// @dev Revokes `role` from `account`.
    ///
    /// If `account` had been granted `role`, emits a {RoleRevoked} event.
    ///
    /// Requirements:
    ///
    /// - the caller must have ``role``'s admin role.
    #[ink(message)]
    pub fn revoke_role(&amp;mut self, role: RoleId, account: AccountId) {
        access_control::Impl::revoke_role(self, role, account)
    }

    /// @dev Revokes `role` from the calling account.
    ///
    /// Roles are often managed via {grant_role} and {revoke_role}: this function's
    /// purpose is to provide a mechanism for accounts to lose their privileges
    /// if they are compromised (such as when a trusted device is misplaced).
    ///
    /// If the calling account had been granted `role`, emits a {RoleRevoked}
    /// event.
    ///
    /// Requirements:
    ///
    /// - the caller must be `account`.
    #[ink(message)]
    pub fn renounce_role(&amp;mut self, role: RoleId, account: AccountId) {
        access_control::Impl::renounce_role(self, role, account)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="module-1"><a class="header" href="#module-1">Module</a></h2>
<p>The module contains the <code>roles</code> and <code>admin_roles</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The Data of access control component
#[cfg_attr(feature = &quot;std&quot;, derive(::ink_storage::traits::StorageLayout))]
#[derive(Debug, SpreadLayout)]
pub struct Data&lt;E&gt;
where
    E: Env,
{
    /// the account - role relationship map
    pub roles: StorageHashMap&lt;(RoleId, E::AccountId), ()&gt;,

    /// the admin role of a role
    pub admin_roles: StorageHashMap&lt;RoleId, RoleId&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages-for-txs-1"><a class="header" href="#messages-for-txs-1">Messages for Txs</a></h2>
<h3 id="grant_role"><a class="header" href="#grant_role">grant_role</a></h3>
<p>Grants <code>role</code> to <code>account</code>. If <code>account</code> had not been already granted <code>role</code>, emits a {RoleGranted}
event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have <code>role</code>'s admin role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// @dev Grants `role` to `account`.
    ///
    /// If `account` had not been already granted `role`, emits a {RoleGranted}
    /// event.
    ///
    /// Requirements:
    ///
    /// - the caller must have ``role``'s admin role.
    fn grant_role(&amp;mut self, role: RoleId, account: E::AccountId) {
        // check the admin role
        self.ensure_admin_role(role, Self::caller());

        self._setup_role(role, account);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="revoke_role"><a class="header" href="#revoke_role">revoke_role</a></h3>
<p>Revokes <code>role</code> from <code>account</code>. If <code>account</code> had been granted <code>role</code>, emits a {RoleRevoked} event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have <code>role</code>'s admin role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// @dev Revokes `role` from `account`.
    ///
    /// If `account` had been granted `role`, emits a {RoleRevoked} event.
    ///
    /// Requirements:
    ///
    /// - the caller must have ``role``'s admin role.
    fn revoke_role(&amp;mut self, role: RoleId, account: E::AccountId) {
        let caller = Self::caller();

        // check the admin role
        self.ensure_admin_role(role, caller.clone());

        // if has not role
        self.get_mut()
            .revoke_role(role, account.clone())
            .expect(&quot;no has role&quot;);

        // emit if revoke role success
        self.emit_event_role_revoked(role, account, caller);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="renounce_role"><a class="header" href="#renounce_role">renounce_role</a></h3>
<p>Revokes <code>role</code> from the calling account.</p>
<p>Roles are often managed via <code>grant_role</code> and <code>revoke_role</code>: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced).</p>
<p>If the calling account had been granted <code>role</code>, emits a <code>RoleRevoked</code> event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must be <code>account</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// @dev Revokes `role` from the calling account.
    ///
    /// Roles are often managed via {grant_role} and {revoke_role}: this function's
    /// purpose is to provide a mechanism for accounts to lose their privileges
    /// if they are compromised (such as when a trusted device is misplaced).
    ///
    /// If the calling account had been granted `role`, emits a {RoleRevoked}
    /// event.
    ///
    /// Requirements:
    ///
    /// - the caller must be `account`.
    fn renounce_role(&amp;mut self, role: RoleId, account: E::AccountId) {
        let caller = Self::caller();

        // check the caller is account
        assert!(caller == account, &quot;account not caller&quot;);

        // if has not role
        self.get_mut()
            .revoke_role(role, account.clone())
            .expect(&quot;no has role&quot;);

        // emit if revoke role success
        self.emit_event_role_revoked(role, account, caller);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-1"><a class="header" href="#message-for-querys-1">Message for Querys</a></h2>
<p>Use <code>has_role</code> and <code>get_role_admin</code> can to get the role releations of accounts.</p>
<h3 id="has_role"><a class="header" href="#has_role">has_role</a></h3>
<p>Returns <code>true</code> if <code>account</code> has been granted <code>role</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns `true` if `account` has been granted `role`.
    fn has_role(&amp;self, role: RoleId, account: E::AccountId) -&gt; bool {
        self.get().has_role(role, account)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_role_admin"><a class="header" href="#get_role_admin">get_role_admin</a></h3>
<p>Returns the admin role that controls <code>role</code>. See {grant_role} and {revoke_role}.</p>
<p>To change a role's admin, use <code>_set_role_admin</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// @dev Returns the admin role that controls `role`. See {grant_role} and
    /// {revoke_role}.
    ///
    /// To change a role's admin, use {_set_role_admin}.
    fn get_role_admin(&amp;self, role: RoleId) -&gt; Option&lt;RoleId&gt; {
        self.get().admin_roles.get(&amp;role).copied()
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-1"><a class="header" href="#apis-1">APIs</a></h2>
<p>Use Apis to check and ensure account has role.</p>
<h3 id="ensure_role"><a class="header" href="#ensure_role">ensure_role</a></h3>
<p>Panic if <code>owner</code> is not an owner.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic if `owner` is not an owner
    fn ensure_role(&amp;self, role: RoleId, account: E::AccountId) {
        assert!(self.has_role(role, account), &quot;role missing&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="ensure_caller_role"><a class="header" href="#ensure_caller_role">ensure_caller_role</a></h3>
<p>Panic if caller is not granted role.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic if caller is not granted role
    fn ensure_caller_role(&amp;self, role: RoleId) {
        self.ensure_role(role, Self::caller());
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="ensure_admin_role"><a class="header" href="#ensure_admin_role">ensure_admin_role</a></h3>
<p>Panic error if <code>account</code> is missing the admin role of the <code>role</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic error if `account` is missing the admin role of the `role`.
    fn ensure_admin_role(&amp;self, role: RoleId, account: E::AccountId) {
        match self.get_role_admin(role) {
            Some(admin_role) =&gt; self.ensure_role(admin_role, account),
            None =&gt; panic!(&quot;admin role missing&quot;),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="check_role"><a class="header" href="#check_role">check_role</a></h3>
<p>Return error if <code>account</code> is missing <code>role</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Return error if `account` is missing `role`.
    fn check_role(&amp;self, role: RoleId, account: E::AccountId) -&gt; Result&lt;()&gt; {
        if self.has_role(role, account) {
            Ok(())
        } else {
            Err(Error::RoleNotFound)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="check_admin_role"><a class="header" href="#check_admin_role">check_admin_role</a></h3>
<p>Return error if <code>account</code> is missing the admin role of the <code>role</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Return error if `account` is missing the admin role of the `role`.
    fn check_admin_role(&amp;self, role: RoleId, account: E::AccountId) -&gt; Result&lt;()&gt; {
        match self.get_role_admin(role) {
            Some(admin_role) =&gt; self.check_role(admin_role, account),
            None =&gt; Err(Error::AdminRoleNotFound),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-1"><a class="header" href="#events-1">Events</a></h2>
<h3 id="roleadminchanged"><a class="header" href="#roleadminchanged">RoleAdminChanged</a></h3>
<p>Emitted when <code>new_admin_role</code> is set as <code>role</code>'s admin role, replacing <code>previous_admin_role</code></p>
<ul>
<li>will emit by call <code>_set_role_admin</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `new_admin_role` is set as ``role``'s
    /// admin role, replacing `previous_admin_role`
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleAdminChanged {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub previous_admin_role: Option&lt;RoleId&gt;,
        #[ink(topic)]
        pub new_admin_role: RoleId,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="rolegranted"><a class="header" href="#rolegranted">RoleGranted</a></h3>
<p>Emitted when <code>account</code> is granted <code>role</code>.</p>
<ul>
<li>will emit by call <code>_setup_role</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `account` is granted `role`.
    ///
    /// `sender` is the account that originated the contract call,
    /// an admin role bearer except when using {_setup_role}.
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleGranted {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="rolerevoked"><a class="header" href="#rolerevoked">RoleRevoked</a></h3>
<p>Emitted when <code>account</code> is revoked <code>role</code>.</p>
<p><code>sender</code> is the account that originated the contract call:</p>
<ul>
<li>if using <code>revoke_role</code>, it is the admin role bearer</li>
<li>if using <code>renounce_role</code>, it is the role bearer (i.e. <code>account</code>)</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `account` is revoked `role`.
    ///
    /// `sender` is the account that originated the contract call:
    ///   - if using `revoke_role`, it is the admin role bearer
    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleRevoked {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="access-control-enumerable"><a class="header" href="#access-control-enumerable">Access Control Enumerable</a></h1>
<p>Extension of <code>Access Control</code> Component that allows enumerating the members of each role.</p>
<h2 id="usage-2"><a class="header" href="#usage-2">Usage</a></h2>
<p><code>Access Control Enumerable</code> is the extension of <code>Access Control</code>, to use this, need import <code>Access Control</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contracts {
    pub use access_control_enumerable::{
        Error,
        Result,
        RoleId,
    };
    use metis_access_control_enumerable as access_control_enumerable;
    use metis_access_control as access_control;
    use metis_lang::{
        import,
        metis,
    };

    #[ink(storage)]
    #[import(access_control, access_control_enumerable)]
    pub struct AccessControl {
        access_control: access_control::Data&lt;AccessControl&gt;,
        access_control_enumerable : access_control_enumerable::Data&lt;AccessControl&gt;,

        value: bool,
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Then Impl the <code>access_control_enumerable</code> for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // Note `use metis_access_control_enumerable as access_control_enumerable;`
    impl access_control_enumerable::Impl&lt;AccessControl&gt; for AccessControl{}
<span class="boring">}
</span></code></pre></pre>
<p>Define the events by <code>Access Control Enumerable</code> Component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `new_admin_role` is set as ``role``'s admin role,
    /// replacing `previous_admin_role`
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleAdminChanged {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub previous_admin_role: Option&lt;RoleId&gt;,
        #[ink(topic)]
        pub new_admin_role: RoleId,
    }

    /// Emitted when `account` is granted `role`.
    ///
    /// `sender` is the account that originated the contract call, an admin role
    /// bearer except when using {_setup_role}.
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleGranted {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }

    /// Emitted when `account` is revoked `role`.
    ///
    /// `sender` is the account that originated the contract call:
    ///   - if using `revoke_role`, it is the admin role bearer
    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleRevoked {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Other is same as <code>Access Control</code> Component, Need to use <code>access_control_enumerable</code> as it changed some logic for <code>Access Control</code> Component.</p>
<p>Impl the constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[ink(constructor)]
    pub fn new(
        fliper: AccountId,
        setter: AccountId,
        admin: AccountId,
    ) -&gt; Self {
        // need new both `access_control` and `access_control_enumerable`
        let mut instance = Self {
            access_control: access_control::Data::new(),
            access_control_enumerable: access_control_enumerable::Data::new(),

            // other logics
        };

        // use _setup_role to initialize the role
        access_control_enumerable::Impl::_setup_role(&amp;mut instance, ROLE_ID_A, fliper);
        access_control_enumerable::Impl::_setup_role(&amp;mut instance, ROLE_ID_B, setter);
        access_control_enumerable::Impl::_setup_role(&amp;mut instance, ROLE_ID_C, admin);

        // use _set_role_admin to initialize the admin role
        access_control_enumerable::Impl::_set_role_admin(
            &amp;mut instance,
            ROLE_ID_A,
            ROLE_ID_C,
        );

        // create the default role
        instance
    }
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>WARNNING</strong> : MUST use <code>access_control_enumerable::Impl::xxxx</code> function call to use access_control_enumerable</p>
</blockquote>
<p>Define Messages for <code>Access Control</code> Component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns `true` if `account` has been granted `role`.
    #[ink(message)]
    pub fn has_role(&amp;self, role: RoleId, account: AccountId) -&gt; bool {
        access_control_enumerable::Impl::has_role(self, role, account)
    }

    /// Returns the admin role that controls `role`. See {grant_role} and
    /// {revoke_role}.
    ///
    /// To change a role's admin, use {_set_role_admin}.
    #[ink(message)]
    pub fn get_role_admin(&amp;self, role: RoleId) -&gt; Option&lt;RoleId&gt; {
        access_control_enumerable::Impl::get_role_admin(self, role)
    }

    /// Grants `role` to `account`.
    ///
    /// If `account` had not been already granted `role`, emits a {RoleGranted}
    /// event.
    ///
    /// Requirements:
    ///
    /// - the caller must have ``role``'s admin role.
    #[ink(message)]
    pub fn grant_role(&amp;mut self, role: RoleId, account: AccountId) {
        access_control_enumerable::Impl::grant_role(self, role, account)
    }

    /// Revokes `role` from `account`.
    ///
    /// If `account` had been granted `role`, emits a {RoleRevoked} event.
    ///
    /// Requirements:
    ///
    /// - the caller must have ``role``'s admin role.
    #[ink(message)]
    pub fn revoke_role(&amp;mut self, role: RoleId, account: AccountId) {
        access_control_enumerable::Impl::revoke_role(self, role, account)
    }

    /// Revokes `role` from the calling account.
    ///
    /// Roles are often managed via {grant_role} and {revoke_role}: this function's
    /// purpose is to provide a mechanism for accounts to lose their privileges
    /// if they are compromised (such as when a trusted device is misplaced).
    ///
    /// If the calling account had been granted `role`, emits a {RoleRevoked}
    /// event.
    ///
    /// Requirements:
    ///
    /// - the caller must be `account`.
    #[ink(message)]
    pub fn renounce_role(&amp;mut self, role: RoleId, account: AccountId) {
        access_control_enumerable::Impl::renounce_role(self, role, account)
    }
<span class="boring">}
</span></code></pre></pre>
<p>Note the message from <code>Access Control Enumerable</code> Component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns one of the accounts that have `role`. `index` must be a
    /// value between 0 and {get_role_member_count}, non-inclusive.
    ///
    /// Role bearers are not sorted in any particular way, and their ordering may
    /// change at any point.
    ///
    /// WARNING: When using {get_role_member} and {get_role_member_count}, make sure
    /// you perform all queries on the same block.
    #[ink(message)]
    pub fn get_role_member(&amp;self, role: RoleId, index: u32) -&gt; AccountId {
        access_control_enumerable::Impl::get_role_member(self, &amp;role, index as usize)
    }

    /// Returns the number of accounts that have `role`. Can be used
    /// together with {getRoleMember} to enumerate all bearers of a role.
    #[ink(message)]
    pub fn get_role_member_count(&amp;self, role: RoleId) -&gt; u32 {
        access_control_enumerable::Impl::get_role_member_count(self, &amp;role) as u32
    }
<span class="boring">}
</span></code></pre></pre>
<p>To Use Roles to control the access in contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // set the state of contract, need setter role
        #[ink(message)]
        pub fn set(&amp;mut self, value: bool) {
            access_control_enumerable::Impl::ensure_caller_role(self, ROLE_ID_SETTER);

            self.value = value;
        }
<span class="boring">}
</span></code></pre></pre>
<p>This functions can use:</p>
<ul>
<li>ensure_role : Panic if <code>owner</code> is not an owner</li>
<li>ensure_caller_role : Panic if caller is not granted role</li>
<li>ensure_admin_role : Panic error if <code>account</code> is missing the admin role of the <code>role</code>.</li>
<li>check_role : Return error if <code>account</code> is missing <code>role</code>.</li>
<li>check_admin_role : Return error if <code>account</code> is missing the admin role of the <code>role</code>.</li>
</ul>
<p>In <a href="access-control/./access-control.html#apis">Access Control APIs</a></p>
<h2 id="module-2"><a class="header" href="#module-2">Module</a></h2>
<p>As the <code>Access Control Enumerable</code> is the extension of <code>Access Control</code>, so it is just has the <code>role_members</code> for check.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Data&lt;E: Env&gt; {
    role_members: StorageHashMap&lt;RoleId, Vec&lt;E::AccountId&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages"><a class="header" href="#messages">Messages</a></h2>
<p>The <code>Access Control Enumerable</code> add <code>get_role_member</code> and <code>get_role_member_count</code> to <code>Access Control</code>.</p>
<h3 id="get_role_member"><a class="header" href="#get_role_member">get_role_member</a></h3>
<p>Returns one of the accounts that have <code>role</code>. <code>index</code> must be a value between 0 and <code>get_role_member_count</code>, non-inclusive.</p>
<p>Role bearers are not sorted in any particular way, and their ordering may change at any point.</p>
<blockquote>
<p>WARNING: When using <code>get_role_member</code> and <code>get_role_member_count</code>, make sure
you perform all queries on the same block. See the following
<a href="https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296">forum post</a>
for more information.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns one of the accounts that have `role`. `index` must be a
    /// value between 0 and {get_role_member_count}, non-inclusive.
    ///
    /// Role bearers are not sorted in any particular way, and their ordering may
    /// change at any point.
    fn get_role_member(&amp;self, role: &amp;RoleId, index: usize) -&gt; E::AccountId {
        match Storage::&lt;E, Data&lt;E&gt;&gt;::get(self).role_members.get(role) {
            None =&gt; panic!(&quot;no found role by id&quot;),
            Some(members) =&gt; members[index].clone(), // will panic when out of index
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_role_member_count"><a class="header" href="#get_role_member_count">get_role_member_count</a></h3>
<p>Returns the number of accounts that have <code>role</code>. Can be used together with {getRoleMember} to enumerate all bearers of a role.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the number of accounts that have `role`. Can be used
    /// together with {getRoleMember} to enumerate all bearers of a role.
    fn get_role_member_count(&amp;self, role: &amp;RoleId) -&gt; usize {
        match Storage::&lt;E, Data&lt;E&gt;&gt;::get(self).role_members.get(role) {
            None =&gt; panic!(&quot;no found role by id&quot;),
            Some(members) =&gt; members.len(),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="governance"><a class="header" href="#governance">Governance</a></h1>
<ul>
<li><a href="./governance/timelock-controller.html">Timelock Controller</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timelock-controller"><a class="header" href="#timelock-controller">Timelock Controller</a></h1>
<p>Contract module which acts as a timelocked controller. When set as the
owner of an <code>Ownable</code> smart contract, it enforces a timelock on all
<code>enuser_caller_owner</code> maintenance operations. This gives time for users of the
controlled contract to exit before a potentially dangerous maintenance
operation is applied.</p>
<p>By default, this contract is self administered, meaning administration tasks
have to go through the timelock process. The proposer (resp executor) role
is in charge of proposing (resp executing) operations. A common use case is
to position this <code>TimelockController</code> as the owner of a smart contract, with
a multisig or a DAO as the sole proposer.</p>
<h2 id="usage-3"><a class="header" href="#usage-3">Usage</a></h2>
<p>To make a timelock controller contract, we should import timelock_controller at first.</p>
<p>Note the <code>timelock_controller</code> component is based on <code>access_control</code> component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    use access_control::RoleId;
    use ink_prelude::vec::Vec;
    use metis_access_control as access_control;
    use metis_lang::{
        import,
        metis,
    };
    use metis_timelock_controller as timelock_controller;
    pub use metis_timelock_controller::{
        Error,
        Result,
    };

    #[ink(storage)]
    #[import(timelock_controller, access_control)]
    pub struct TimelockController {
        timelock_controller: timelock_controller::Data&lt;TimelockController&gt;,
        access_control: access_control::Data&lt;TimelockController&gt;,
    }

    // other logic for
}
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    impl timelock_controller::Impl&lt;TimelockController&gt; for TimelockController {}
<span class="boring">}
</span></code></pre></pre>
<p>Then add the event for timelock_controller, we add the events for the <code>access_control</code> component also:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when a call is scheduled as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallScheduled {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
        pub predecessor: Option&lt;[u8; 32]&gt;,
        pub delay: Timestamp,
    }

    /// Emitted when a call is performed as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallExecuted {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
    }

    /// Emitted when operation `id` is cancelled.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct Cancelled {
        #[ink(topic)]
        pub id: [u8; 32],
    }

    /// Emitted when the minimum delay for future operations is modified.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct MinDelayChange {
        pub old_duration: Timestamp,
        pub new_duration: Timestamp,
    }

    /// Emitted when `new_admin_role` is set as ``role``'s
    /// admin role, replacing `previous_admin_role`
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleAdminChanged {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub previous_admin_role: Option&lt;RoleId&gt;,
        #[ink(topic)]
        pub new_admin_role: RoleId,
    }

    /// Emitted when `account` is granted `role`.
    ///
    /// `sender` is the account that originated the contract call,
    /// an admin role bearer except when using {_setupRole}.
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleGranted {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }

    /// Emitted when `account` is revoked `role`.
    ///
    /// `sender` is the account that originated the contract call:
    ///   - if using `revoke_role`, it is the admin role bearer
    ///   - if using `renounce_role`, it is the role bearer (i.e. `account`)
    #[ink(event)]
    #[metis(access_control)]
    pub struct RoleRevoked {
        #[ink(topic)]
        pub role: RoleId,
        #[ink(topic)]
        pub account: AccountId,
        #[ink(topic)]
        pub sender: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl TimelockController {
        #[ink(constructor)]
        pub fn new(
            min_delay: Timestamp,
            proposers: Vec&lt;AccountId&gt;,
            executors: Vec&lt;AccountId&gt;,
        ) -&gt; Self {
            let mut instance = Self {
                timelock_controller: timelock_controller::Data::new(),
                access_control: access_control::Data::new(),
            };

            timelock_controller::Impl::init(
                &amp;mut instance,
                min_delay,
                proposers,
                executors,
            );
            instance
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the messages for contract.</p>
<blockquote>
<p>NOTE: the <code>execute</code> message should be <code>payable</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl TimelockController{
        /// Returns `true` if `account` has been granted `role`.
        #[ink(message)]
        pub fn has_role(&amp;self, role: RoleId, account: AccountId) -&gt; bool {
            access_control::Impl::has_role(self, role, account)
        }

        /// @dev Returns the admin role that controls `role`. See {grant_role} and
        /// {revoke_role}.
        ///
        /// To change a role's admin, use {_setRoleAdmin}.
        #[ink(message)]
        pub fn get_role_admin(&amp;self, role: RoleId) -&gt; Option&lt;RoleId&gt; {
            access_control::Impl::get_role_admin(self, role)
        }

        /// @dev Grants `role` to `account`.
        ///
        /// If `account` had not been already granted `role`, emits a {RoleGranted}
        /// event.
        ///
        /// Requirements:
        ///
        /// - the caller must have ``role``'s admin role.
        #[ink(message)]
        pub fn grant_role(&amp;mut self, role: RoleId, account: AccountId) {
            access_control::Impl::grant_role(self, role, account)
        }

        /// @dev Revokes `role` from `account`.
        ///
        /// If `account` had been granted `role`, emits a {RoleRevoked} event.
        ///
        /// Requirements:
        ///
        /// - the caller must have ``role``'s admin role.
        #[ink(message)]
        pub fn revoke_role(&amp;mut self, role: RoleId, account: AccountId) {
            access_control::Impl::revoke_role(self, role, account)
        }

        /// @dev Revokes `role` from the calling account.
        ///
        /// Roles are often managed via {grant_role} and {revoke_role}: this function's
        /// purpose is to provide a mechanism for accounts to lose their privileges
        /// if they are compromised (such as when a trusted device is misplaced).
        ///
        /// If the calling account had been granted `role`, emits a {RoleRevoked}
        /// event.
        ///
        /// Requirements:
        ///
        /// - the caller must be `account`.
        #[ink(message)]
        pub fn renounce_role(&amp;mut self, role: RoleId, account: AccountId) {
            access_control::Impl::renounce_role(self, role, account)
        }

        /// Returns whether an id correspond to a registered operation. This
        /// includes both Pending, Ready and Done operations.
        #[ink(message)]
        pub fn is_operation(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation(self, &amp;id)
        }

        /// Returns whether an operation is pending or not.
        #[ink(message)]
        pub fn is_operation_pending(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation_pending(self, &amp;id)
        }

        /// Returns whether an operation is ready or not.
        #[ink(message)]
        pub fn is_operation_ready(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation_ready(self, &amp;id)
        }

        /// Returns whether an operation is done or not.
        #[ink(message)]
        pub fn is_operation_done(&amp;self, id: [u8; 32]) -&gt; bool {
            timelock_controller::Impl::is_operation_done(self, &amp;id)
        }

        /// Returns the timestamp at with an operation becomes ready (0 for
        /// unset operations, 1 for done operations).
        #[ink(message)]
        pub fn get_timestamp(&amp;self, id: [u8; 32]) -&gt; Timestamp {
            timelock_controller::Impl::get_timestamp(self, &amp;id)
        }

        /// Returns the minimum delay for an operation to become valid.
        ///
        /// This value can be changed by executing an operation that calls `updateDelay`.
        #[ink(message)]
        pub fn get_min_delay(&amp;self) -&gt; Timestamp {
            timelock_controller::Impl::get_min_delay(self)
        }

        /// Returns the identifier of an operation containing a single
        /// transaction.
        #[ink(message)]
        pub fn hash_operation(
            &amp;self,
            target: AccountId,
            value: Balance,
            data: Vec&lt;u8&gt;,
            predecessor: Option&lt;[u8; 32]&gt;,
            salt: [u8; 32],
        ) -&gt; [u8; 32] {
            timelock_controller::Impl::hash_operation(
                self,
                &amp;target,
                &amp;value,
                &amp;data,
                &amp;predecessor,
                &amp;salt,
            )
        }

        /// Schedule an operation containing a single transaction.
        ///
        /// Emits a `CallScheduled` event.
        ///
        /// Requirements:
        ///
        /// - the caller must have the 'proposer' role.
        #[ink(message)]
        pub fn schedule(
            &amp;mut self,
            target: AccountId,
            value: Balance,
            data: Vec&lt;u8&gt;,
            predecessor: Option&lt;[u8; 32]&gt;,
            salt: [u8; 32],
            delay: Timestamp,
        ) {
            timelock_controller::Impl::schedule(
                self,
                target,
                value,
                data,
                predecessor,
                salt,
                delay,
            )
        }

        /// Cancel an operation.
        ///
        /// Requirements:
        ///
        /// - the caller must have the 'proposer' role.
        #[ink(message)]
        pub fn cancel(&amp;mut self, id: [u8; 32]) {
            timelock_controller::Impl::cancel(self, id)
        }

        /// Execute an (ready) operation containing a single transaction.
        ///
        /// Emits a `CallExecuted` event.
        ///
        /// Requirements:
        ///
        /// - the caller must have the 'executor' role.
        #[ink(message, payable)]
        pub fn execute(
            &amp;mut self,
            target: AccountId,
            value: Balance,
            data: Vec&lt;u8&gt;,
            predecessor: Option&lt;[u8; 32]&gt;,
            salt: [u8; 32],
        ) {
            timelock_controller::Impl::execute(
                self,
                target,
                value,
                data,
                predecessor,
                salt,
            )
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<p>the caller to call need impl the <code>on_call</code> message:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Receiver {
        #[ink(message, payable)]
        pub fn on_call(
            &amp;mut self,
            _operator: AccountId,
            _data: Vec&lt;u8&gt;,
        ) -&gt; bool {
            unimplemented!()
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>like this, NOTE the <code>on_call</code> should be payable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[ink(message, payable)]
        pub fn on_call(
            &amp;mut self,
            operator: AccountId,
            data: Vec&lt;u8&gt;,
        ) -&gt; bool {
            // value to transferred_balance
            let value = Self::env().transferred_balance();

            // emit events
            Self::env().emit_event(CallReceived {
                operator,
                value,
                data,
            });

            // if return false should be error.
            true
        }
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages-for-txs-2"><a class="header" href="#messages-for-txs-2">Messages for Txs</a></h2>
<h3 id="schedule"><a class="header" href="#schedule">schedule</a></h3>
<p>Schedule an operation containing a single transaction.</p>
<p>Emits a <code>CallScheduled</code> event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have the 'proposer' role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Schedule an operation containing a single transaction.
    ///
    /// Emits a `CallScheduled` event.
    ///
    /// Requirements:
    ///
    /// - the caller must have the 'proposer' role.
    fn schedule(
        &amp;mut self,
        target: E::AccountId,
        value: E::Balance,
        data: Vec&lt;u8&gt;,
        predecessor: Option&lt;[u8; 32]&gt;,
        salt: [u8; 32],
        delay: E::Timestamp,
    ) {
        access_control::Impl::ensure_caller_role(self, PROPOSER_ROLE);

        let id = self.hash_operation(&amp;target, &amp;value, &amp;data, &amp;predecessor, &amp;salt);

        self._schedule(id, delay);

        self.emit_event_call_scheduled(id, target, value, data, predecessor, delay);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="cancel"><a class="header" href="#cancel">cancel</a></h3>
<p>Cancel an operation.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have the 'proposer' role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Cancel an operation.
    ///
    /// Requirements:
    ///
    /// - the caller must have the 'proposer' role.
    fn cancel(&amp;mut self, id: [u8; 32]) {
        access_control::Impl::ensure_caller_role(self, PROPOSER_ROLE);

        assert!(
            self.is_operation_pending(&amp;id),
            &quot;TimelockController: operation cannot be cancelled&quot;
        );
        Storage::&lt;E, Data&lt;E&gt;&gt;::get_mut(self).timestamps.take(&amp;id);

        self.emit_event_cancelled(id);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="execute"><a class="header" href="#execute">execute</a></h3>
<p>Execute an (ready) operation containing a single transaction.</p>
<p>Emits a <code>CallExecuted</code> event.</p>
<p>Requirements:</p>
<ul>
<li>the caller must have the 'executor' role.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Execute an (ready) operation containing a single transaction.
    ///
    /// Emits a `CallExecuted` event.
    ///
    /// Requirements:
    ///
    /// - the caller must have the 'executor' role.
    fn execute(
        &amp;mut self,
        target: E::AccountId,
        value: E::Balance,
        data: Vec&lt;u8&gt;,
        predecessor: Option&lt;[u8; 32]&gt;,
        salt: [u8; 32],
    ) {
        self.ensure_only_role_or_open_role(EXECUTOR_ROLE);

        let id = self.hash_operation(&amp;target, &amp;value, &amp;data, &amp;predecessor, &amp;salt);

        self._before_call(predecessor);
        self._call(id, target, value, data);
        self._after_call(id);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-2"><a class="header" href="#message-for-querys-2">Message for Querys</a></h2>
<h3 id="is_operation"><a class="header" href="#is_operation">is_operation</a></h3>
<p>Returns whether an id correspond to a registered operation. This includes both Pending, Ready and Done operations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an id correspond to a registered operation. This
    /// includes both Pending, Ready and Done operations.
    fn is_operation(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        self.get_timestamp(id) &gt; E::Timestamp::from(0_u8)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operation_pending"><a class="header" href="#is_operation_pending">is_operation_pending</a></h3>
<p>Returns whether an operation is pending or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an operation is pending or not.
    fn is_operation_pending(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        self.get_timestamp(id) &gt; E::Timestamp::from(_DONE_TIMESTAMP)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operation_ready"><a class="header" href="#is_operation_ready">is_operation_ready</a></h3>
<p>Returns whether an operation is ready or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an operation is ready or not.
    fn is_operation_ready(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        let timestamp = self.get_timestamp(id);
        timestamp &gt; E::Timestamp::from(_DONE_TIMESTAMP)
            &amp;&amp; timestamp &lt;= Self::block_timestamp()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operation_done"><a class="header" href="#is_operation_done">is_operation_done</a></h3>
<p>Returns whether an operation is done or not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether an operation is done or not.
    fn is_operation_done(&amp;self, id: &amp;[u8; 32]) -&gt; bool {
        self.get_timestamp(id) == E::Timestamp::from(_DONE_TIMESTAMP)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_timestamp"><a class="header" href="#get_timestamp">get_timestamp</a></h3>
<p>Returns the timestamp at with an operation becomes ready (0 for unset operations, 1 for done operations).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the timestamp at with an operation becomes ready (0 for
    /// unset operations, 1 for done operations).
    fn get_timestamp(&amp;self, id: &amp;[u8; 32]) -&gt; E::Timestamp {
        *Storage::&lt;E, Data&lt;E&gt;&gt;::get(self)
            .timestamps
            .get(id)
            .unwrap_or(&amp;E::Timestamp::from(0_u8))
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_min_delay"><a class="header" href="#get_min_delay">get_min_delay</a></h3>
<p>Returns the minimum delay for an operation to become valid.</p>
<p>This value can be changed by executing an operation that calls <code>update_delay</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the minimum delay for an operation to become valid.
    ///
    /// This value can be changed by executing an operation that calls `update_delay`.
    fn get_min_delay(&amp;self) -&gt; E::Timestamp {
        *Storage::&lt;E, Data&lt;E&gt;&gt;::get(self).min_delay
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="hash_operation"><a class="header" href="#hash_operation">hash_operation</a></h3>
<p>Returns the identifier of an operation containing a single transaction.</p>
<blockquote>
<p>NOTE: This <code>hash = Blake2x256(target + value + data + predecessor + salt)</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the identifier of an operation containing a single
    /// transaction.
    fn hash_operation(
        &amp;self,
        target: &amp;E::AccountId,
        value: &amp;E::Balance,
        data: &amp;Vec&lt;u8&gt;,
        predecessor: &amp;Option&lt;[u8; 32]&gt;,
        salt: &amp;[u8; 32],
    ) -&gt; [u8; 32] {
        // for target + value + data + predecessor + salt
        let mut hash_data: Vec&lt;u8&gt; = Vec::with_capacity(128 + data.len());

        hash_data.append(&amp;mut target.encode());
        hash_data.append(&amp;mut value.encode());
        hash_data.append(&amp;mut data.clone());
        hash_data.append(&amp;mut predecessor.encode());
        for s in salt.into_iter() {
            hash_data.push(s.clone());
        }

        Self::hash_bytes::&lt;Blake2x256&gt;(&amp;hash_data)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-2"><a class="header" href="#apis-2">Apis</a></h2>
<h3 id="ensure_only_role_or_open_role"><a class="header" href="#ensure_only_role_or_open_role">ensure_only_role_or_open_role</a></h3>
<p>To make a function callable only by a certain role. In
addition to checking the sender's role, <code>AccountId::default()</code> 's role is also
considered. Granting a role to <code>AccountId::default()</code> is equivalent to enabling
this role for everyone.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// To make a function callable only by a certain role. In
    /// addition to checking the sender's role, `address(0)` 's role is also
    /// considered. Granting a role to `address(0)` is equivalent to enabling
    /// this role for everyone.
    fn ensure_only_role_or_open_role(&amp;self, role: RoleId) {
        if !access_control::Impl::has_role(self, role, E::AccountId::default()) {
            access_control::Impl::ensure_caller_role(self, role);
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-2"><a class="header" href="#events-2">Events</a></h2>
<h3 id="callscheduled"><a class="header" href="#callscheduled">CallScheduled</a></h3>
<p>Emitted when a call is scheduled as part of operation <code>id</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when a call is scheduled as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallScheduled {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
        pub predecessor: Option&lt;[u8; 32]&gt;,
        pub delay: Timestamp,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="callexecuted"><a class="header" href="#callexecuted">CallExecuted</a></h3>
<p>Emitted when a call is performed as part of operation <code>id</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when a call is performed as part of operation `id`.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct CallExecuted {
        #[ink(topic)]
        pub id: [u8; 32],
        pub target: AccountId,
        pub value: Balance,
        pub data: Vec&lt;u8&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="cancelled"><a class="header" href="#cancelled">Cancelled</a></h3>
<p>Emitted when operation <code>id</code> is cancelled.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when operation `id` is cancelled.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct Cancelled {
        #[ink(topic)]
        pub id: [u8; 32],
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="mindelaychange"><a class="header" href="#mindelaychange">MinDelayChange</a></h3>
<p>Emitted when the minimum delay for future operations is modified.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when the minimum delay for future operations is modified.
    #[ink(event)]
    #[metis(timelock_controller)]
    pub struct MinDelayChange {
        pub old_duration: Timestamp,
        pub new_duration: Timestamp,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens"><a class="header" href="#tokens">Tokens</a></h1>
<p>Componends for impl Tokens contract.</p>
<ul>
<li><a href="./tokens/erc20.html">ERC20</a></li>
<li><a href="./tokens/erc721.html">ERC721</a></li>
<li><a href="./tokens/erc777.html">ERC777</a></li>
<li><a href="./tokens/erc1155.html">ERC1155</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc20"><a class="header" href="#erc20">ERC20</a></h1>
<p>Details of ERC20 can be found in <a href="https://eips.ethereum.org/EIPS/eip-20">ERC20</a>.</p>
<h2 id="usage-4"><a class="header" href="#usage-4">Usage</a></h2>
<p>To make a new erc20-like token, we should import erc20 at first:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    // use Error and Result for erc20
    pub use erc20::{
        Error,
        Result,
    };

    // use erc20 component
    use metis_erc20 as erc20;
    use metis_lang::{
        import,
        metis,
    };

    /// ERC-20 contract.
    #[ink(storage)]
    #[import(erc20)]
    pub struct Erc20 {
        erc20: erc20::Data&lt;Erc20&gt;,
    }

    // other logics
}
<span class="boring">}
</span></code></pre></pre>
<p>Then add the event for erc20:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub value: Balance,
    }

    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    impl erc20::Impl&lt;Erc20&gt; for Erc20 {
        /// Hook that is called before any transfer of tokens. This includes
        /// minting and burning.
        ///
        /// Calling conditions:
        ///
        /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
        /// will be to transferred to `to`.
        /// - when `from` is zero, `amount` tokens will be minted for `to`.
        /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.
        /// - `from` and `to` are never both zero.
        fn _before_token_transfer(
            &amp;mut self,
            _from: &amp;E::AccountId,
            _to: &amp;E::AccountId,
            _amount: E::Balance,
        ) -&gt; Result&lt;()&gt;{
            // some logic

            Ok(())
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Erc20 {
    /// the constructor of the contract
    #[ink(constructor)]
    pub fn new(
        name: String,
        symbol: String,
        decimals: u8,
        initial_supply: Balance,
    ) -&gt; Self {
        let mut instance = Self {
            erc20: erc20::Data::new(),
        };

        erc20::Impl::init(&amp;mut instance, name, symbol, decimals, initial_supply);

        // do some other logic here

        instance
    }
  }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the messages for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Erc20 {
        /// Returns the name of the token.
        #[ink(message)]
        pub fn name(&amp;self) -&gt; String {
            erc20::Impl::name(self)
        }

        /// Returns the symbol of the token,
        /// usually a shorter version of the name.
        #[ink(message)]
        pub fn symbol(&amp;self) -&gt; String {
            erc20::Impl::symbol(self)
        }

        /// Returns the number of decimals used to
        /// get its user representation.
        /// For example, if `decimals` equals `2`,
        /// a balance of `505` tokens should
        /// be displayed to a user as `5,05` (`505 / 10 ** 2`).
        ///
        /// Tokens usually opt for a value of 18,
        /// imitating the relationship between
        /// Ether and Wei in ETH. This is the value {ERC20} uses,
        /// unless this function is
        /// overridden;
        ///
        /// NOTE: This information is only used for _display_ purposes:
        /// it in no way affects any of the arithmetic of the contract
        #[ink(message)]
        pub fn decimals(&amp;self) -&gt; u8 {
            erc20::Impl::decimals(self)
        }

        /// Returns the amount of tokens in existence.
        #[ink(message)]
        pub fn total_supply(&amp;self) -&gt; Balance {
            erc20::Impl::total_supply(self)
        }

        /// Returns the amount of tokens owned by `account`.
        #[ink(message)]
        pub fn balance_of(&amp;self, owner: AccountId) -&gt; Balance {
            erc20::Impl::balance_of(self, &amp;owner)
        }

        /// Returns the remaining number of tokens that `spender` will be
        /// allowed to spend on behalf of `owner` through {transferFrom}. This is
        /// zero by default.
        ///
        /// This value changes when {approve} or {transferFrom} are called.
        #[ink(message)]
        pub fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance {
            erc20::Impl::allowance(self, &amp;owner, &amp;spender)
        }

        /// Moves `amount` tokens from the caller's account to `recipient`.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc20::Impl::transfer(self, &amp;to, value)
        }

        /// Sets `amount` as the allowance of `spender` over the caller's tokens.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// IMPORTANT: Beware that changing an allowance with this method brings
        /// the risk that someone may use both the old and the new allowance
        /// by unfortunate transaction ordering. One possible solution to 
        /// mitigate this race condition is to first reduce the spender's 
        /// allowance to 0 and set the desired value afterwards:
        /// &lt;https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&gt;
        ///
        /// Emits an {Approval} event.
        #[ink(message)]
        pub fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc20::Impl::approve(self, &amp;spender, value)
        }

        /// Moves `amount` tokens from `sender` to `recipient` using the
        /// allowance mechanism. `amount` is then deducted from the caller's
        /// allowance.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            value: Balance,
        ) -&gt; Result&lt;()&gt; {
            erc20::Impl::transfer_from(self, &amp;from, &amp;to, value)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<h2 id="messages-for-txs-3"><a class="header" href="#messages-for-txs-3">Messages for Txs</a></h2>
<h3 id="transfer"><a class="header" href="#transfer">transfer</a></h3>
<p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p>
<p>Returns a Result indicating whether the operation succeeded.</p>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from the caller's account to `recipient`.
    ///
    /// Returns a Result indicating whether the operation succeeded.
    ///
    /// Emits a `Transfer` event.
    fn transfer(&amp;mut self, to: &amp;E::AccountId, value: E::Balance) -&gt; Result&lt;()&gt; {
        self._transfer_from_to(&amp;Self::caller(), to, value)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approve"><a class="header" href="#approve">approve</a></h3>
<p>Sets <code>amount</code> as the allowance of <code>spender</code> over the caller's tokens.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>IMPORTANT: Beware that changing an allowance with this method brings the risk
that someone may use both the old and the new allowance by unfortunate
transaction ordering. One possible solution to mitigate this race
condition is to first reduce the spender's allowance to 0 and set the
desired value afterwards:
<a href="https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729">https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</a></p>
<p>Emits an <code>Approval</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Sets `amount` as the allowance of `spender` over the caller's tokens.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// IMPORTANT: Beware that changing an allowance with this method brings the risk
    /// that someone may use both the old and the new allowance by unfortunate
    /// transaction ordering. One possible solution to mitigate this race
    /// condition is to first reduce the spender's allowance to 0 and set the
    /// desired value afterwards:
    /// &lt;https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&gt;
    ///
    /// Emits an `Approval` event.
    fn approve(&amp;mut self, spender: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        self._approve(&amp;Self::caller(), spender, amount)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="transfer_from"><a class="header" href="#transfer_from">transfer_from</a></h3>
<p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the
allowance mechanism. <code>amount</code> is then deducted from the caller's
allowance.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from `sender` to `recipient` using the
    /// allowance mechanism. `amount` is then deducted from the caller's
    /// allowance.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// Emits a `Transfer` event.
    fn transfer_from(
        &amp;mut self,
        from: &amp;E::AccountId,
        to: &amp;E::AccountId,
        amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        let caller = &amp;Self::caller();

        let current_allowance = self.get().allowance(from, caller);
        if current_allowance &lt; amount {
            return Err(Error::InsufficientAllowance)
        }

        self._transfer_from_to(from, to, amount)?;

        self._approve(from, caller, current_allowance - amount)?;

        Ok(())
    }

<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-3"><a class="header" href="#message-for-querys-3">Message for Querys</a></h2>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>Returns the name of the token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the name of the token.
    fn name(&amp;self) -&gt; String {
        self.get().name().clone()
    }

<span class="boring">}
</span></code></pre></pre>
<h3 id="symbol"><a class="header" href="#symbol">symbol</a></h3>
<p>Returns the symbol of the token, usually a shorter version of the name.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the symbol of the token, usually a shorter version of the name.
    fn symbol(&amp;self) -&gt; String {
        self.get().symbol().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="decimals"><a class="header" href="#decimals">decimals</a></h3>
<p>Returns the number of decimals used to get its user representation.
For example, if <code>decimals</code> equals <code>2</code>, a balance of <code>505</code> tokens should
be displayed to a user as <code>5,05</code> (<code>505 / 10 ** 2</code>).</p>
<p>Tokens usually opt for a value of 18, imitating the relationship between
Ether and Wei in ETH. This is the value {ERC20} uses, unless this function is
overridden;</p>
<blockquote>
<p>NOTE: This information is only used for <em>display</em> purposes: it in
no way affects any of the arithmetic of the contract</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the number of decimals used to get its user representation.
    /// For example, if `decimals` equals `2`, a balance of `505` tokens should
    /// be displayed to a user as `5,05` (`505 / 10 ** 2`).
    ///
    /// Tokens usually opt for a value of 18, imitating the relationship between
    /// Ether and Wei in ETH. This is the value {ERC20} uses, unless this function is
    /// overridden;
    ///
    /// NOTE: This information is only used for _display_ purposes: it in
    /// no way affects any of the arithmetic of the contract
    fn decimals(&amp;self) -&gt; u8 {
        self.get().decimals().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance_of"><a class="header" href="#balance_of">balance_of</a></h3>
<p>Returns the amount of tokens owned by <code>account</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens owned by `account`.
    fn balance_of(&amp;self, account: &amp;E::AccountId) -&gt; E::Balance {
        self.get().balance_of(account)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="total_supply"><a class="header" href="#total_supply">total_supply</a></h3>
<p>Returns the amount of tokens in existence.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens in existence.
    fn total_supply(&amp;self) -&gt; E::Balance {
        self.get().total_supply()
    }

<span class="boring">}
</span></code></pre></pre>
<h3 id="allowance"><a class="header" href="#allowance">allowance</a></h3>
<p>Returns the remaining number of tokens that <code>spender</code> will be
allowed to spend on behalf of <code>owner</code> through <code>transfer_from</code>. This is
zero by default.</p>
<p>This value changes when <code>approve</code> or <code>transfer_from</code> are called.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the remaining number of tokens that `spender` will be
    /// allowed to spend on behalf of `owner` through `transfer_from`. This is
    /// zero by default.
    ///
    /// This value changes when `approve` or `transfer_from` are called.
    fn allowance(&amp;self, owner: &amp;E::AccountId, spender: &amp;E::AccountId) -&gt; E::Balance {
        self.get().allowance(owner, spender)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-3"><a class="header" href="#apis-3">APIs</a></h2>
<p>If the contract need make some logic by token, developers can based on this apis:</p>
<ul>
<li><code>_mint</code> : mint token to a account with amount</li>
<li><code>_burn</code> : burn token from a account by amount</li>
<li><code>_transfer_from_to</code> : move token from a account to another</li>
</ul>
<h3 id="_mint"><a class="header" href="#_mint">_mint</a></h3>
<p>Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing
the total supply.</p>
<p>Emits a <code>Transfer</code> event with <code>from</code> set to the zero address.</p>
<p>Requirements:</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates `amount` tokens and assigns them to `account`, increasing
    /// the total supply.
    ///
    /// Emits a `Transfer` event with `from` set to the zero address.
    ///
    /// Requirements:
    ///
    /// - `account` cannot be the zero address.
    fn _mint(&amp;mut self, account: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();
        if account == null_account {
            return Err(Error::AccountIsZero)
        }

        self._before_token_transfer(null_account, account, amount)?;

        let total_supply = self.get().total_supply();
        let account_balance = self.get().balance_of(account);

        self.get_mut().set_total_supply(total_supply + amount);
        self.get_mut()
            .set_balance(account, account_balance + amount);

        self.emit_event_transfer(None, Some(account.clone()), amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_burn"><a class="header" href="#_burn">_burn</a></h3>
<p>Destroys <code>amount</code> tokens from <code>account</code>, reducing the total supply.</p>
<p>Emits a <code>Transfer</code> event with <code>to</code> set to the None address.</p>
<p>Requirements:</p>
<ul>
<li><code>account</code> must have at least <code>amount</code> tokens.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Destroys `amount` tokens from `account`, reducing the
    /// total supply.
    ///
    /// Emits a `Transfer` event with `to` set to the None address.
    ///
    /// Requirements:
    ///
    /// - `account` must have at least `amount` tokens.
    fn _burn(&amp;mut self, account: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();

        if account == &amp;E::AccountId::default() {
            return Err(Error::AccountIsZero)
        }

        self._before_token_transfer(account, null_account, amount)?;

        let account_balance = self.get().balance_of(account);
        let total_supply = self.get().total_supply();

        if account_balance &lt; amount {
            return Err(Error::InsufficientBalance)
        }

        self.get_mut()
            .set_balance(account, account_balance - amount);
        self.get_mut().set_total_supply(total_supply - amount);

        self.emit_event_transfer(Some(account.clone()), None, amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_transfer_from_to"><a class="header" href="#_transfer_from_to">_transfer_from_to</a></h3>
<p>Moves tokens <code>amount</code> from <code>sender</code> to <code>recipient</code>.</p>
<p>This is internal function is equivalent to <code>transfer</code>, and can be used to</p>
<p>e.g. implement automatic token fees, slashing mechanisms, etc.
Emits a <code>Transfer</code> event.</p>
<p>Requirements:</p>
<ul>
<li><code>sender</code> cannot be the zero address.</li>
<li><code>recipient</code> cannot be the zero address.</li>
<li><code>sender</code> must have a balance of at least <code>amount</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves tokens `amount` from `sender` to `recipient`.
    ///
    /// This is internal function is equivalent to `transfer`, and can be used to
    /// e.g. implement automatic token fees, slashing mechanisms, etc.
    ///
    /// Emits a `Transfer` event.
    ///
    /// Requirements:
    ///
    /// - `sender` cannot be the zero address.
    /// - `recipient` cannot be the zero address.
    /// - `sender` must have a balance of at least `amount`.
    fn _transfer_from_to(
        &amp;mut self,
        sender: &amp;E::AccountId,
        recipient: &amp;E::AccountId,
        amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();

        if sender == null_account || recipient == null_account {
            return Err(Error::AccountIsZero)
        }

        self._before_token_transfer(sender, recipient, amount)?;

        let sender_balance = self.get().balance_of(sender);
        if sender_balance &lt; amount {
            return Err(Error::InsufficientBalance)
        }

        self.get_mut().set_balance(sender, sender_balance - amount);
        let recipient_balance = self.get().balance_of(recipient);
        self.get_mut()
            .set_balance(recipient, recipient_balance + amount);

        self.emit_event_transfer(
            Some(sender.clone()),
            Some(recipient.clone()),
            amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<h3 id="_before_token_transfer"><a class="header" href="#_before_token_transfer">_before_token_transfer</a></h3>
<p>Hook that is called before any transfer of tokens. This includes
minting and burning.</p>
<p>Calling conditions:</p>
<ul>
<li>when <code>from</code> and <code>to</code> are both non-zero, <code>amount</code> of <code>from</code>'s tokens
will be to transferred to <code>to</code>.</li>
<li>when <code>from</code> is zero, <code>amount</code> tokens will be minted for <code>to</code>.</li>
<li>when <code>to</code> is zero, <code>amount</code> of <code>from</code>'s tokens will be burned.</li>
<li><code>from</code> and <code>to</code> are never both zero.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Hook that is called before any transfer of tokens. This includes
    /// minting and burning.
    ///
    /// Calling conditions:
    ///
    /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    /// will be to transferred to `to`.
    /// - when `from` is zero, `amount` tokens will be minted for `to`.
    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.
    /// - `from` and `to` are never both zero.
    fn _before_token_transfer(
        &amp;mut self,
        _from: &amp;E::AccountId,
        _to: &amp;E::AccountId,
        _amount: E::Balance,
    ) -&gt; Result&lt;()&gt;{
        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-3"><a class="header" href="#events-3">Events</a></h2>
<h3 id="transfer-1"><a class="header" href="#transfer-1">Transfer</a></h3>
<p>Event emitted when a token transfer occurs.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approval"><a class="header" href="#approval">Approval</a></h3>
<p>Event emitted when an approval occurs that <code>spender</code> is allowed to withdraw up to the amount of <code>value</code> tokens from <code>owner</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc721"><a class="header" href="#erc721">ERC721</a></h1>
<p>Details of ERC721 can be found in <a href="https://eips.ethereum.org/EIPS/eip-721">ERC721</a>.</p>
<h2 id="usage-5"><a class="header" href="#usage-5">Usage</a></h2>
<p>To make a new erc721-like token, we should import erc721 at first:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    use ink_prelude::{
        string::String,
        vec::Vec,
    };
    use metis_erc721 as erc721;
    pub use metis_erc721::{
        Error,
        Result,
        TokenId,
    };
    use metis_lang::{
        import,
        metis,
    };

    /// A ERC721 contract.
    #[ink(storage)]
    #[import(erc721)]
    pub struct Erc721 {
        erc721: erc721::Data&lt;Erc721&gt;,
    }

    // other logics
}
<span class="boring">}
</span></code></pre></pre>
<p>Then add the event for erc721:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `token_id` token is transferred from `from` to `to`.
    #[ink(event)]
    #[metis(erc721)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub token_id: TokenId,
    }

    /// Emitted when `owner` enables `approved` to manage the `token_id` token.
    #[ink(event)]
    #[metis(erc721)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: Option&lt;AccountId&gt;,
        pub token_id: TokenId,
    }

    /// Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
    #[ink(event)]
    #[metis(erc721)]
    pub struct ApprovalForAll {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub operator: AccountId,
        pub approved: bool,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    impl erc721::Impl&lt;Erc721&gt; for Erc721 {
        /// Hook that is called before any token transfer. This includes minting
        /// and burning.
        ///
        /// Calling conditions:
        ///
        /// - When `from` and `to` are both non-zero, `from`'s `token_id` will be
        /// transferred to `to`.
        /// - When `from` is zero, `token_id` will be minted for `to`.
        /// - When `to` is zero, `from`'s `token_id` will be burned.
        /// - `from` and `to` are never both zero.
        fn _before_token_transfer(
            &amp;mut self,
            _from: Option&lt;AccountId&gt;,
            _to: Option&lt;AccountId&gt;,
            _token_id: &amp;TokenId,
        ) -&gt; Result&lt;()&gt; {
            Ok(())
        }

        /// Base URI for computing `token_url`. If set, the resulting URI for each
        /// token will be the concatenation of the `baseURI` and the `token_id`. Empty
        /// by default, can be overriden in child contracts.
        fn _base_url(&amp;self) -&gt; String {
            String::from(&quot;https://test/&quot;)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Erc721 {
        /// the constructor of the contract
        #[ink(constructor)]
        pub fn new(name: String, symbol: String) -&gt; Self {
            let mut instance = Self {
                erc721: erc721::Data::new(),
            };

            erc721::Impl::init(&amp;mut instance, name, symbol);

            // other logic

            instance
        }
  }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the messages for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Erc721 {
        /// Returns the name of the token.
        #[ink(message)]
        pub fn name(&amp;self) -&gt; String {
            erc721::Impl::name(self)
        }

        /// Returns the symbol of the token, usually a shorter version of the name.
        #[ink(message)]
        pub fn symbol(&amp;self) -&gt; String {
            erc721::Impl::symbol(self)
        }

        /// Returns the Uniform Resource Identifier (URI) for `token_id` token.
        #[ink(message)]
        pub fn token_url(&amp;self, token_id: TokenId) -&gt; String {
            erc721::Impl::token_url(self, &amp;token_id)
        }

        /// @dev Returns the number of tokens in ``owner``'s account.
        #[ink(message)]
        pub fn balance_of(&amp;self, owner: AccountId) -&gt; u64 {
            erc721::Impl::balance_of(self, &amp;owner)
        }

        /// @dev Returns the owner of the `token_id` token.
        ///
        /// Requirements:
        ///
        /// - `token_id` must exist.
        #[ink(message)]
        pub fn owner_of(&amp;self, token_id: TokenId) -&gt; AccountId {
            erc721::Impl::owner_of(self, &amp;token_id)
        }

        /// @dev Returns the account approved for `token_id` token.
        ///
        /// Requirements:
        ///
        /// - `token_id` must exist.
        #[ink(message)]
        pub fn get_approved(&amp;self, token_id: TokenId) -&gt; Option&lt;AccountId&gt; {
            erc721::Impl::get_approved(self, &amp;token_id)
        }

        /// @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
        ///
        /// See {setApprovalForAll}
        #[ink(message)]
        pub fn is_approved_for_all(
            &amp;self,
            owner: AccountId,
            operator: AccountId,
        ) -&gt; bool {
            erc721::Impl::is_approved_for_all(self, &amp;owner, &amp;operator)
        }

        /// @dev Gives permission to `to` to transfer `token_id` token to another account.
        /// The approval is cleared when the token is transferred.
        ///
        /// Only a single account can be approved at a time, so approving the zero address clears previous approvals.
        ///
        /// Requirements:
        ///
        /// - The caller must own the token or be an approved operator.
        /// - `token_id` must exist.
        ///
        /// Emits an {Approval} event.
        #[ink(message)]
        pub fn approve(&amp;mut self, to: Option&lt;AccountId&gt;, token_id: TokenId) {
            erc721::Impl::approve(self, to, &amp;token_id)
        }

        /// @dev Approve or remove `operator` as an operator for the caller.
        /// Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
        ///
        /// Requirements:
        ///
        /// - The `operator` cannot be the caller.
        ///
        /// Emits an {ApprovalForAll} event.
        #[ink(message)]
        pub fn set_approval_for_all(&amp;mut self, operator: AccountId, approved: bool) {
            erc721::Impl::set_approval_for_all(self, operator, approved)
        }

        /// @dev Transfers `token_id` token from `from` to `to`.
        ///
        /// WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.
        ///
        /// Requirements:
        ///
        /// - `from` cannot be the zero address.
        /// - `to` cannot be the zero address.
        /// - `token_id` token must be owned by `from`.
        /// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            token_id: TokenId,
        ) -&gt; Result&lt;()&gt; {
            erc721::Impl::transfer_from(self, from, to, token_id)
        }

        /// @dev Safely transfers `token_id` token from `from` to `to`, checking first that contract recipients
        /// are aware of the ERC721 protocol to prevent tokens from being forever locked.
        ///
        /// Requirements:
        ///
        /// - `from` cannot be the zero address.
        /// - `to` cannot be the zero address.
        /// - `token_id` token must exist and be owned by `from`.
        /// - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.
        /// - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn safe_transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            token_id: TokenId,
        ) -&gt; Result&lt;()&gt; {
            erc721::Impl::safe_transfer_from(self, from, to, token_id)
        }

        /// @dev Safely transfers `token_id` token from `from` to `to`.
        ///
        /// Requirements:
        ///
        /// - `from` cannot be the zero address.
        /// - `to` cannot be the zero address.
        /// - `token_id` token must exist and be owned by `from`.
        /// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
        /// - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn safe_transfer_from_with_data(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            token_id: TokenId,
            data: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            erc721::Impl::safe_transfer_from_with_data(self, from, to, token_id, data)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<h2 id="messages-for-txs-4"><a class="header" href="#messages-for-txs-4">Messages for Txs</a></h2>
<h3 id="approve-1"><a class="header" href="#approve-1">approve</a></h3>
<p>Gives permission to <code>to</code> to transfer <code>token_id</code> token to another account.
The approval is cleared when the token is transferred.</p>
<p>Only a single account can be approved at a time, so approving the
zero address clears previous approvals.</p>
<p>Requirements:</p>
<ul>
<li>The caller must own the token or be an approved operator.</li>
<li><code>token_id</code> must exist.</li>
</ul>
<p>Emits an <code>Approval</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Gives permission to `to` to transfer `token_id` token to another account.
    /// The approval is cleared when the token is transferred.
    ///
    /// Only a single account can be approved at a time, so approving the
    /// zero address clears previous approvals.
    ///
    /// Requirements:
    ///
    /// - The caller must own the token or be an approved operator.
    /// - `token_id` must exist.
    ///
    /// Emits an `Approval` event.
    fn approve(&amp;mut self, to: Option&lt;E::AccountId&gt;, token_id: &amp;TokenId) {
        let owner = self.owner_of(token_id);
        let caller = Self::caller();

        assert!(
            to.is_none() || to.as_ref().unwrap() != &amp;owner,
            &quot;ERC721: approval to current owner&quot;
        );

        assert!(
            caller == owner || self.is_approved_for_all(&amp;owner, &amp;caller),
            &quot;ERC721: approve caller is not owner nor approved for all&quot;
        );

        self._approve(to, token_id);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="transfer_from-1"><a class="header" href="#transfer_from-1">transfer_from</a></h3>
<p>Transfers <code>token_id</code> token from <code>from</code> to <code>to</code>.</p>
<p>WARNING: Usage of this method is discouraged,
use <code>safe_transfer_from</code> whenever possible.</p>
<p>Requirements:</p>
<ul>
<li><code>from</code> cannot be the zero address.</li>
<li><code>to</code> cannot be the zero address.</li>
<li><code>token_id</code> token must be owned by <code>from</code>.</li>
<li>If the caller is not <code>from</code>, it must be approved to move this token by either <code>approve</code> or <code>set_approval_for_all</code>.</li>
</ul>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Transfers `token_id` token from `from` to `to`.
    ///
    /// WARNING: Usage of this method is discouraged,
    /// use `safe_transfer_from` whenever possible.
    ///
    /// Requirements:
    ///
    /// - `from` cannot be the zero address.
    /// - `to` cannot be the zero address.
    /// - `token_id` token must be owned by `from`.
    /// - If the caller is not `from`, it must be approved
    ///   to move this token by either `approve` or `set_approval_for_all`.
    ///
    /// Emits a `Transfer` event.
    fn transfer_from(
        &amp;mut self,
        from: E::AccountId,
        to: E::AccountId,
        token_id: TokenId,
    ) -&gt; Result&lt;()&gt; {
        assert!(
            self._is_approved_or_owner(&amp;Self::caller(), &amp;token_id),
            &quot;ERC721: transfer caller is not owner nor approved&quot;
        );

        self._transfer(&amp;from, &amp;to, &amp;token_id)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="set_approval_for_all"><a class="header" href="#set_approval_for_all">set_approval_for_all</a></h3>
<p>Approve or remove <code>operator</code> as an operator for the caller.
Operators can call <code>transfer_from</code> or <code>safe_transfer_from</code> for
any token owned by the caller.</p>
<p>Requirements:</p>
<ul>
<li>The <code>operator</code> cannot be the caller.</li>
</ul>
<p>Emits an <code>ApprovalForAll</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Approve or remove `operator` as an operator for the caller.
    /// Operators can call `transfer_from` or `safe_transfer_from` for
    /// any token owned by the caller.
    ///
    /// Requirements:
    ///
    /// - The `operator` cannot be the caller.
    ///
    /// Emits an `ApprovalForAll` event.
    fn set_approval_for_all(&amp;mut self, operator: E::AccountId, approved: bool) {
        let caller = Self::caller();
        assert!(operator != caller, &quot;ERC721: approve to caller&quot;);

        self.get_mut()
            .set_approval_for_all(caller.clone(), operator.clone(), approved);
        self.emit_event_approval_for_all(caller, operator, approved);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="safe_transfer_from"><a class="header" href="#safe_transfer_from">safe_transfer_from</a></h3>
<p>Safely transfers <code>token_id</code> token from <code>from</code> to <code>to</code>, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked.</p>
<p>Requirements:</p>
<ul>
<li><code>from</code> cannot be the zero address.</li>
<li><code>to</code> cannot be the zero address.</li>
<li><code>token_id</code> token must exist and be owned by <code>from</code>.</li>
<li>If the caller is not <code>from</code>, it must be have been allowed to move this token by either <code>approve</code> or <code>set_approval_for_all</code>.</li>
<li>If <code>to</code> refers to a smart contract, it must implement <code>on_erc721_received</code>, which is called upon a safe transfer.</li>
</ul>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Safely transfers `token_id` token from `from` to `to`,
    /// checking first that contract recipients are aware of 
    /// the ERC721 protocol to prevent tokens from being forever locked.
    ///
    /// Requirements:
    ///
    /// - `from` cannot be the zero address.
    /// - `to` cannot be the zero address.
    /// - `token_id` token must exist and be owned by `from`.
    /// - If the caller is not `from`, it must be have been allowed to
    ///   move this token by either `approve` or `set_approval_for_all`.
    /// - If `to` refers to a smart contract, it must implement 
    ///   `on_erc721_received`, which is called upon a safe transfer.
    ///
    /// Emits a `Transfer` event.
    fn safe_transfer_from(
        &amp;mut self,
        from: E::AccountId,
        to: E::AccountId,
        token_id: TokenId,
    ) -&gt; Result&lt;()&gt; {
        self.safe_transfer_from_with_data(from, to, token_id, Vec::default())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="safe_transfer_from_with_data"><a class="header" href="#safe_transfer_from_with_data">safe_transfer_from_with_data</a></h3>
<p>Safely transfers <code>token_id</code> token from <code>from</code> to <code>to</code>.</p>
<p>Requirements:</p>
<ul>
<li><code>from</code> cannot be the zero address.</li>
<li><code>to</code> cannot be the zero address.</li>
<li><code>token_id</code> token must exist and be owned by <code>from</code>.</li>
<li>If the caller is not <code>from</code>, it must be approved to move this token by either <code>approve</code> or <code>set_approval_for_all</code>.</li>
<li>If <code>to</code> refers to a smart contract, it must implement <code>on_erc721_received</code>, which is called upon a safe transfer.</li>
</ul>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Safely transfers `token_id` token from `from` to `to`.
    ///
    /// Requirements:
    ///
    /// - `from` cannot be the zero address.
    /// - `to` cannot be the zero address.
    /// - `token_id` token must exist and be owned by `from`.
    /// - If the caller is not `from`, it must be approved to
    ///   move this token by either `approve` or `set_approval_for_all`.
    /// - If `to` refers to a smart contract, it must implement
    ///   `on_erc721_received`, which is called upon a safe transfer.
    ///
    /// Emits a `Transfer` event.
    fn safe_transfer_from_with_data(
        &amp;mut self,
        from: E::AccountId,
        to: E::AccountId,
        token_id: TokenId,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        assert!(
            self._is_approved_or_owner(&amp;Self::caller(), &amp;token_id),
            &quot;ERC721: transfer caller is not owner nor approved&quot;
        );

        self._safe_transfer(from, to, token_id, data)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-4"><a class="header" href="#message-for-querys-4">Message for Querys</a></h2>
<h3 id="name-1"><a class="header" href="#name-1">name</a></h3>
<p>Returns the name of the token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the name of the token.
    fn name(&amp;self) -&gt; String {
        self.get().name().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="symbol-1"><a class="header" href="#symbol-1">symbol</a></h3>
<p>Returns the symbol of the token, usually a shorter version of the name.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the symbol of the token, usually a shorter version of the name.
    fn symbol(&amp;self) -&gt; String {
        self.get().symbol().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="token_url"><a class="header" href="#token_url">token_url</a></h3>
<p>Returns the Uniform Resource Identifier (URI) for <code>token_id</code> token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the Uniform Resource Identifier (URI) for `token_id` token.
    fn token_url(&amp;self, token_id: &amp;TokenId) -&gt; String {
        assert!(
            self._exists(token_id),
            &quot;ERC721Metadata: URI query for nonexistent token&quot;
        );

        let mut base_url = self._base_url().clone();

        match base_url.len() {
            0 =&gt; String::from(&quot;&quot;),
            _ =&gt; {
                base_url.push_str(token_id.to_string().as_str());
                base_url
            }
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance_of-1"><a class="header" href="#balance_of-1">balance_of</a></h3>
<p>Returns the number of tokens in <code>owner</code>'s account.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the number of tokens in ``owner``'s account.
    fn balance_of(&amp;self, account: &amp;E::AccountId) -&gt; u64 {
        self.get().balance_of(account)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="owner_of"><a class="header" href="#owner_of">owner_of</a></h3>
<p>Returns the owner of the <code>token_id</code> token.</p>
<p>Requirements:</p>
<ul>
<li><code>token_id</code> must exist.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the owner of the `token_id` token.
    ///
    /// Requirements:
    ///
    /// - `token_id` must exist.
    fn owner_of(&amp;self, token_id: &amp;TokenId) -&gt; E::AccountId {
        match self.get().owners.get(token_id) {
            Some(owner) =&gt; owner.clone(),
            None =&gt; panic!(&quot;ERC721: owner query for nonexistent token&quot;),
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="get_approved"><a class="header" href="#get_approved">get_approved</a></h3>
<p>Returns the account approved for <code>token_id</code> token.</p>
<p>Requirements:</p>
<ul>
<li><code>token_id</code> must exist.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the account approved for `token_id` token.
    ///
    /// Requirements:
    ///
    /// - `token_id` must exist.
    fn get_approved(&amp;self, token_id: &amp;TokenId) -&gt; Option&lt;E::AccountId&gt; {
        assert!(
            self._exists(token_id),
            &quot;ERC721: approved query for nonexistent token&quot;
        );

        match self.get().token_approvals.get(token_id) {
            Some(a) =&gt; Some(a.clone()),
            None =&gt; None,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_approved_for_all"><a class="header" href="#is_approved_for_all">is_approved_for_all</a></h3>
<p>Returns if the <code>operator</code> is allowed to manage all of the assets of <code>owner</code>.</p>
<p>See <code>set_approval_for_all</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns if the `operator` is allowed to manage all of the assets of `owner`.
    ///
    /// See `set_approval_for_all`
    fn is_approved_for_all(&amp;self, owner: &amp;E::AccountId, operator: &amp;E::AccountId) -&gt; bool {
        self.get()
            .is_approved_for_all(owner.clone(), operator.clone())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-4"><a class="header" href="#apis-4">APIs</a></h2>
<p>If the contract need make some logic by token, developers can based on this apis:</p>
<ul>
<li><code>_exists</code> : is a token_id exists</li>
<li><code>_mint</code>, <code>_safe_mint</code> and <code>_safe_mint_with_data</code> : mint token to a account with amount</li>
<li><code>_burn</code> : burn token from a account by amount</li>
</ul>
<h3 id="_exists"><a class="header" href="#_exists">_exists</a></h3>
<p>Returns whether <code>token_id</code> exists.</p>
<p>Tokens can be managed by their owner or approved accounts via
<code>approve</code> or <code>set_approval_for_all</code>.</p>
<p>Tokens start existing when they are minted (<code>_mint</code>),
and stop existing when they are burned (<code>_burn</code>).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns whether `token_id` exists.
    ///
    /// Tokens can be managed by their owner or approved accounts via
    /// `approve` or `set_approval_for_all`.
    ///
    /// Tokens start existing when they are minted (`_mint`),
    /// and stop existing when they are burned (`_burn`).
    fn _exists(&amp;self, token_id: &amp;TokenId) -&gt; bool {
        match self.get().owners.get(token_id) {
            Some(_) =&gt; true,
            None =&gt; false,
        }
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_mint-1"><a class="header" href="#_mint-1">_mint</a></h3>
<p>Mints <code>token_id</code> and transfers it to <code>to</code>.</p>
<blockquote>
<p>WARNING: Usage of this method is discouraged, use <code>_safe_mint</code> whenever possible</p>
</blockquote>
<p>Requirements:</p>
<ul>
<li><code>token_id</code> must not exist.</li>
<li><code>to</code> cannot be the zero address.</li>
</ul>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Mints `token_id` and transfers it to `to`.
    ///
    /// WARNING: Usage of this method is discouraged, use `_safe_mint` whenever possible
    ///
    /// Requirements:
    ///
    /// - `token_id` must not exist.
    /// - `to` cannot be the zero address.
    ///
    /// Emits a `Transfer` event.
    fn _mint(&amp;mut self, to: &amp;E::AccountId, token_id: &amp;TokenId) -&gt; Result&lt;()&gt; {
        assert!(
            *to != E::AccountId::default(),
            &quot;ERC721: mint to the zero address&quot;
        );
        assert!(!self._exists(token_id), &quot;ERC721: token already minted&quot;);

        self._before_token_transfer(None, Some(to.clone()), token_id)?;

        self.get_mut().balance_inc(to);
        self.get_mut().owners.insert(token_id.clone(), to.clone());

        self.emit_event_transfer(None, Some(to.clone()), token_id.clone());

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_safe_mint"><a class="header" href="#_safe_mint">_safe_mint</a></h3>
<p>Safely mints <code>token_id</code> and transfers it to <code>to</code>.</p>
<p>Requirements:</p>
<ul>
<li><code>token_id</code> must not exist.</li>
<li>If <code>to</code> refers to a smart contract, it must implement <code>on_erc721_received</code>, which is called upon a safe transfer.</li>
</ul>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Safely mints `token_id` and transfers it to `to`.
    ///
    /// Requirements:
    ///
    /// - `token_id` must not exist.
    /// - If `to` refers to a smart contract, it must implement `on_erc721_received`,
    ///  which is called upon a safe transfer.
    ///
    /// Emits a `Transfer` event.
    fn _safe_mint(&amp;mut self, to: E::AccountId, token_id: TokenId) -&gt; Result&lt;()&gt; {
        self._safe_mint_with_data(to, token_id, Vec::default())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_safe_mint_with_data"><a class="header" href="#_safe_mint_with_data">_safe_mint_with_data</a></h3>
<p>Same as <code>_safe_mint</code>, with an additional <code>data</code> parameter which is forwarded in <code>on_erc721_received</code> to contract recipients.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Same as `_safe_mint`, with an additional `data` parameter which is
    /// forwarded in `on_erc721_received` to contract recipients.
    fn _safe_mint_with_data(
        &amp;mut self,
        to: E::AccountId,
        token_id: TokenId,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        self._mint(&amp;to, &amp;token_id)?;

        assert!(
            self._check_on_erc721_received(E::AccountId::default(), to, token_id, data),
            &quot;ERC721: transfer to non ERC721Receiver implementer&quot;
        );

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_burn-1"><a class="header" href="#_burn-1">_burn</a></h3>
<p>Destroys <code>token_id</code>.
The approval is cleared when the token is burned.</p>
<p>Requirements:</p>
<ul>
<li><code>token_id</code> must exist.</li>
</ul>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Destroys `token_id`.
    /// The approval is cleared when the token is burned.
    ///
    /// Requirements:
    ///
    /// - `token_id` must exist.
    ///
    /// Emits a `Transfer` event.
    fn _burn(&amp;mut self, token_id: &amp;TokenId) -&gt; Result&lt;()&gt; {
        let owner = self.owner_of(token_id);

        self._before_token_transfer(Some(owner.clone()), None, token_id)?;

        // Clear approvals
        self._approve(None, token_id);

        self.get_mut().balance_dec(&amp;owner);

        self.get_mut().owners.take(token_id);

        self.emit_event_transfer(Some(owner), None, *token_id);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="hooks-1"><a class="header" href="#hooks-1">Hooks</a></h2>
<p>ERC721 have two hooks : <code>_before_token_transfer</code> and <code>_base_url</code>:</p>
<h3 id="_before_token_transfer-1"><a class="header" href="#_before_token_transfer-1">_before_token_transfer</a></h3>
<p>Hook that is called before any token transfer. This includes minting and burning.</p>
<p>Calling conditions:</p>
<ul>
<li>When <code>from</code> and <code>to</code> are both non-zero, <code>from</code>'s <code>token_id</code> will be
transferred to <code>to</code>.</li>
<li>When <code>from</code> is zero, <code>token_id</code> will be minted for <code>to</code>.</li>
<li>When <code>to</code> is zero, <code>from</code>'s <code>token_id</code> will be burned.</li>
<li><code>from</code> and <code>to</code> are never both zero.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Hook that is called before any token transfer. This includes minting
    /// and burning.
    ///
    /// Calling conditions:
    ///
    /// - When `from` and `to` are both non-zero, `from`'s `token_id` will be
    /// transferred to `to`.
    /// - When `from` is zero, `token_id` will be minted for `to`.
    /// - When `to` is zero, `from`'s `token_id` will be burned.
    /// - `from` and `to` are never both zero.
    fn _before_token_transfer(
        &amp;mut self,
        from: Option&lt;E::AccountId&gt;,
        to: Option&lt;E::AccountId&gt;,
        token_id: &amp;TokenId,
    ) -&gt; Result&lt;()&gt;;
<span class="boring">}
</span></code></pre></pre>
<h3 id="_base_url"><a class="header" href="#_base_url">_base_url</a></h3>
<p>Base URI for computing <code>token_url</code>. If set, the resulting URI for each
token will be the concatenation of the <code>baseURI</code> and the <code>token_id</code>. Empty
by default, can be overriden in child contracts.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Base URI for computing `token_url`. If set, the resulting URI for each
    /// token will be the concatenation of the `baseURI` and the `token_id`. Empty
    /// by default, can be overriden in child contracts.
    fn _base_url(&amp;self) -&gt; String;
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-4"><a class="header" href="#events-4">Events</a></h2>
<h3 id="transfer-2"><a class="header" href="#transfer-2">Transfer</a></h3>
<p>Emitted when <code>token_id</code> token is transferred from <code>from</code> to <code>to</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `token_id` token is transferred from `from` to `to`.
    #[ink(event)]
    #[metis(erc721)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub token_id: TokenId,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approval-1"><a class="header" href="#approval-1">Approval</a></h3>
<p>Emitted when <code>owner</code> enables <code>approved</code> to manage the <code>token_id</code> token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `owner` enables `approved` to manage the `token_id` token.
    #[ink(event)]
    #[metis(erc721)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: Option&lt;AccountId&gt;,
        pub token_id: TokenId,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approvalforall"><a class="header" href="#approvalforall">ApprovalForAll</a></h3>
<p>Emitted when <code>owner</code> enables or disables (<code>approved</code>) <code>operator</code> to manage all of its assets.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `owner` enables or disables (`approved`) `operator` to
    /// manage all of its assets.
    #[ink(event)]
    #[metis(erc721)]
    pub struct ApprovalForAll {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub operator: AccountId,
        pub approved: bool,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc777"><a class="header" href="#erc777">ERC777</a></h1>
<p>Details of ERC777 can be found in <a href="https://eips.ethereum.org/EIPS/eip-777">ERC777</a>.</p>
<h2 id="usage-6"><a class="header" href="#usage-6">Usage</a></h2>
<p>To make a new erc777-like token, we should import erc777 at first:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod erc777_contract {
    use super::super::behavior;
    pub use erc777::{
        Error,
        Result,
    };
    use metis_erc777 as erc777;
    use metis_lang::{
        import,
        metis,
    };

    #[ink(storage)]
    #[import(erc777)]
    pub struct Erc777 {
        erc777: erc777::Data&lt;Erc777&gt;,
    }

    // Note: Now version of metis not support auto impl for erc777
    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    impl erc777::Impl&lt;Erc777&gt; for Erc777 {}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: Now version of metis not support auto impl for erc777.</p>
<p>Should add:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>   #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
   impl erc777::Impl&lt;Erc777&gt; for Erc777 {}
<span class="boring">}
</span></code></pre></pre>
</blockquote>
<p>Then add the event for erc777:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>     /// Event emitted when a token transfer occurs.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub value: Balance,
    }

    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        pub value: Balance,
    }

    /// Indicate a send of `amount` of tokens from the `from` address to the `to`
    /// address by the `operator` address.
    /// 
    /// NOTE: This event MUST NOT be emitted outside of
    /// a send or an ERC-20 transfer process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Sent {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: AccountId,
        #[ink(topic)]
        pub to: AccountId,
        pub amount: Balance,
        pub data: Vec&lt;u8&gt;,
        pub operator_data: Vec&lt;u8&gt;,
    }

    /// Indicate the minting of `amount` of tokens to the `to` address by
    /// the `operator` address.
    ///
    /// NOTE: This event MUST NOT be emitted outside of a mint process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Minted {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub to: AccountId,
        pub amount: Balance,
        pub data: Vec&lt;u8&gt;,
        pub operator_data: Vec&lt;u8&gt;,
    }

    /// Indicate the burning of `amount` of tokens from the `from` address
    /// by the `operator` address.
    /// 
    /// NOTE: This event MUST NOT be emitted outside of a burn process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Burned {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: AccountId,
        pub amount: Balance,
        pub data: Vec&lt;u8&gt;,
        pub operator_data: Vec&lt;u8&gt;,
    }

    /// Indicates the authorization of `operator` as an operator for `holder`.
    /// 
    /// NOTE: This event MUST NOT be emitted outside
    /// of an operator authorization process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct AuthorizedOperator {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub token_holder: AccountId,
    }

    /// Indicates the revocation of `operator` as an operator for `holder`.
    /// 
    /// NOTE: This event MUST NOT be emitted outside
    /// of an operator revocation process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct RevokedOperator {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub token_holder: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Erc777 {
        #[ink(constructor)]
        pub fn new(
            name: String,
            symbol: String,
            decimals: u8,
            initial_supply: Balance,
        ) -&gt; Self {
            let mut instance = Self {
                erc777: erc777::Data::new(),
            };

            erc777::Impl::init(&amp;mut instance, 
                name, symbol, decimals,
                initial_supply);

            // other logics
            instance
        }
    }

Then implement the messages for contract:

```rust
    impl Erc777 {
        /// Returns the name of the token.
        #[ink(message)]
        pub fn name(&amp;self) -&gt; String {
            erc777::Impl::name(self)
        }

        /// Returns the symbol of the token, usually a shorter version of the name.
        #[ink(message)]
        pub fn symbol(&amp;self) -&gt; String {
            erc777::Impl::symbol(self)
        }

        /// Returns the number of decimals used to get its user representation.
        /// For example, if `decimals` equals `2`, a balance of `505` tokens should
        /// be displayed to a user as `5,05` (`505 / 10 ** 2`).
        ///
        /// Tokens usually opt for a value of 18, imitating the relationship between
        /// Ether and Wei in ETH. This is the value `ERC20` uses, unless this function is
        /// overridden;
        ///
        /// NOTE: This information is only used for _display_ purposes: it in
        /// no way affects any of the arithmetic of the contract
        #[ink(message)]
        pub fn decimals(&amp;self) -&gt; u8 {
            erc777::Impl::decimals(self)
        }

        /// Returns the smallest part of the token that is not divisible. This
        /// means all token operations (creation, movement and destruction) must have
        /// amounts that are a multiple of this number.
        ///
        /// For most token contracts, this value will equal 1.
        #[ink(message)]
        pub fn granularity(&amp;self) -&gt; Balance {
            erc777::Impl::granularity(self)
        }

        /// Returns the amount of tokens in existence.
        #[ink(message)]
        pub fn total_supply(&amp;self) -&gt; Balance {
            erc777::Impl::total_supply(self)
        }

        /// Returns the amount of tokens owned by `account`.
        #[ink(message)]
        pub fn balance_of(&amp;self, owner: AccountId) -&gt; Balance {
            erc777::Impl::balance_of(self, &amp;owner)
        }

        /// Moves `amount` tokens from the caller's account to `recipient`.
        ///
        /// If send or receive hooks are registered for the caller and `recipient`,
        /// the corresponding functions will be called with `data` and empty
        /// `operator_data`. See `erc777_sender` and `erc777_recipient`.
        ///
        /// Emits a `Sent` event.
        ///
        /// Requirements
        ///
        /// - the caller must have at least `amount` tokens.
        /// - `recipient` cannot be the zero address.
        /// - if `recipient` is a contract, it must implement the `erc777_recipient` interface.
        #[ink(message)]
        pub fn send(
            &amp;mut self,
            recipient: AccountId,
            amount: Balance,
            data: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            erc777::Impl::send(self, recipient, amount, data)
        }

        /// Moves `amount` tokens from the caller's account to `recipient`.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// Emits a `Transfer` event.
        #[ink(message)]
        pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc777::Impl::transfer(self, &amp;to, value)
        }

        /// Destroys `amount` tokens from the caller's account, reducing the
        /// total supply.
        ///
        /// If a send hook is registered for the caller, the corresponding function
        /// will be called with `data` and empty `operator_data`. See `erc777_sender`.
        ///
        /// Emits a `Burned` event.
        ///
        /// Requirements
        ///
        /// - the caller must have at least `amount` tokens.
        #[ink(message)]
        pub fn burn(&amp;mut self, amount: Balance, data: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
            erc777::Impl::burn(self, amount, data)
        }

        /// Returns true if an account is an operator of `token_holder`.
        /// Operators can send and burn tokens on behalf of their owners. All
        /// accounts are their own operator.
        ///
        /// See `operator_send` and `operator_burn`.
        #[ink(message)]
        pub fn is_operator_for(
            &amp;self,
            operator: AccountId,
            token_holder: AccountId,
        ) -&gt; bool {
            erc777::Impl::is_operator_for(self, operator, token_holder)
        }

        /// Make an account an operator of the caller.
        ///
        /// See `is_operator_for`.
        ///
        /// Emits an `AuthorizedOperator` event.
        ///
        /// Requirements
        ///
        /// - `operator` cannot be calling address.
        #[ink(message)]
        pub fn authorize_operator(&amp;mut self, operator: AccountId) {
            erc777::Impl::authorize_operator(self, operator)
        }

        /// Revoke an account's operator status for the caller.
        ///
        /// See `is_operator_for` and `default_operators`.
        ///
        /// Emits a `RevokedOperator` event.
        ///
        /// Requirements
        ///
        /// - `operator` cannot be calling address.
        #[ink(message)]
        pub fn revoke_operator(&amp;mut self, operator: AccountId) {
            erc777::Impl::revoke_operator(self, operator)
        }

        /// Returns the list of default operators. These accounts are operators
        /// for all token holders, even if `authorize_operator` was never called on
        /// them.
        ///
        /// This list is immutable, but individual holders may revoke these via
        /// `revoke_operator`, in which case `is_operator_for` will return false.
        #[ink(message)]
        pub fn default_operators(&amp;self) -&gt; Vec&lt;AccountId&gt; {
            erc777::Impl::default_operators(self)
        }

        /// Moves `amount` tokens from `sender` to `recipient`. The caller must
        /// be an operator of `sender`.
        ///
        /// If send or receive hooks are registered for `sender` and `recipient`,
        /// the corresponding functions will be called with `data` and
        /// `operator_data`. See `erc777_sender` and `erc777_recipient`.
        ///
        /// Emits a `Sent` event.
        ///
        /// Requirements
        ///
        /// - `sender` cannot be the zero address.
        /// - `sender` must have at least `amount` tokens.
        /// - the caller must be an operator for `sender`.
        /// - `recipient` cannot be the zero address.
        /// - if `recipient` is a contract, it must implement the `erc777_recipient` interface.
        #[ink(message)]
        pub fn operator_send(
            &amp;mut self,
            sender: AccountId,
            recipient: AccountId,
            amount: Balance,
            data: Vec&lt;u8&gt;,
            operator_data: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            erc777::Impl::operator_send(
                self,
                sender,
                recipient,
                amount,
                data,
                operator_data,
            )
        }

        /// Destroys `amount` tokens from `account`, reducing the total supply.
        /// The caller must be an operator of `account`.
        ///
        /// If a send hook is registered for `account`, the corresponding function
        /// will be called with `data` and `operator_data`. See `erc777_sender`.
        ///
        /// Emits a `Burned` event.
        ///
        /// Requirements
        ///
        /// - `account` cannot be the zero address.
        /// - `account` must have at least `amount` tokens.
        /// - the caller must be an operator for `account`.
        #[ink(message)]
        pub fn operator_burn(
            &amp;mut self,
            account: AccountId,
            amount: Balance,
            data: Vec&lt;u8&gt;,
            operator_data: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            erc777::Impl::operator_burn(self, account, amount, data, operator_data)
        }

        /// Returns the remaining number of tokens that `spender` will be
        /// allowed to spend on behalf of `owner` through `transfer_from`. This is
        /// zero by default.
        ///
        /// This value changes when `approve` or `transfer_from` are called.
        #[ink(message)]
        pub fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance {
            erc777::Impl::allowance(self, &amp;owner, &amp;spender)
        }

        /// Sets `amount` as the allowance of `spender` over the caller's tokens.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// IMPORTANT: Beware that changing an allowance with this method brings the risk
        /// that someone may use both the old and the new allowance by unfortunate
        /// transaction ordering. One possible solution to mitigate this race
        /// condition is to first reduce the spender's allowance to 0 and set the
        /// desired value afterwards:
        /// &lt;https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&gt;
        ///
        /// Emits an `Approval` event.
        #[ink(message)]
        pub fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc777::Impl::approve(self, &amp;spender, value)
        }

        /// Moves `amount` tokens from `sender` to `recipient` using the
        /// allowance mechanism. `amount` is then deducted from the caller's
        /// allowance.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// Emits a `Transfer` event.
        #[ink(message)]
        pub fn transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            value: Balance,
        ) -&gt; Result&lt;()&gt; {
            erc777::Impl::transfer_from(self, &amp;from, &amp;to, value)
        }

        /// Creates `amount` tokens and assigns them to `account`, increasing
        /// the total supply.
        ///
        /// If a send hook is registered for `account`, the corresponding function
        /// will be called with `operator`, `data` and `operator_data`.
        ///
        /// See `erc777_sender` and `erc777_recipient`.
        ///
        /// Emits `Minted` and `Transfer` events.
        ///
        /// Requirements
        ///
        /// - `account` cannot be the zero address.
        /// - if `account` is a contract, it must implement the `erc777_recipient` interface.
        #[ink(message)]
        pub fn mint(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc777::Impl::_mint(self, to, value, Vec::default(), Vec::default())
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<h2 id="messages-for-txs-5"><a class="header" href="#messages-for-txs-5">Messages for Txs</a></h2>
<h3 id="send"><a class="header" href="#send">send</a></h3>
<p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p>
<p>If send or receive hooks are registered for the caller and <code>recipient</code>,
the corresponding functions will be called with <code>data</code> and empty
<code>operator_data</code>. See <code>erc777_sender</code> and <code>erc777_recipient</code>.</p>
<p>Emits a <code>Sent</code> event.</p>
<p>Requirements</p>
<ul>
<li>the caller must have at least <code>amount</code> tokens.</li>
<li><code>recipient</code> cannot be the zero address.</li>
<li>if <code>recipient</code> is a contract, it must implement the <code>erc777_recipient</code> interface.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from the caller's account to `recipient`.
    ///
    /// If send or receive hooks are registered for the caller and `recipient`,
    /// the corresponding functions will be called with `data` and empty
    /// `operator_data`. See `erc777_sender` and `erc777_recipient`.
    ///
    /// Emits a `Sent` event.
    ///
    /// Requirements
    ///
    /// - the caller must have at least `amount` tokens.
    /// - `recipient` cannot be the zero address.
    /// - if `recipient` is a contract, it must implement the `erc777_recipient`
    /// interface.
    fn send(
        &amp;mut self,
        recipient: E::AccountId,
        amount: E::Balance,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        self._send(
            Self::caller(),
            recipient,
            amount,
            data,
            Vec::default(),
            true,
        )
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="transfer-3"><a class="header" href="#transfer-3">transfer</a></h3>
<p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from the caller's account to `recipient`.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// Emits a `Transfer` event.
    fn transfer(&amp;mut self, recipient: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();
        let from = &amp;Self::caller();

        if recipient == null_account {
            return Err(Error::AccountIsZero)
        }

        let null_data = &amp;Vec::&lt;u8&gt;::default();

        self._call_tokens_to_send(
            &amp;from,
            &amp;Some(&amp;from),
            &amp;Some(&amp;recipient),
            &amp;amount,
            null_data,
            null_data,
        );

        self._move(&amp;from, &amp;from, &amp;recipient, &amp;amount, null_data, null_data)?;

        self._call_tokens_received(
            &amp;from,
            &amp;Some(&amp;from),
            &amp;Some(&amp;recipient),
            &amp;amount,
            null_data,
            null_data,
            false,
        );

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="burn"><a class="header" href="#burn">burn</a></h3>
<p>Destroys <code>amount</code> tokens from the caller's account, reducing the
total supply.</p>
<p>If a send hook is registered for the caller, the corresponding function
will be called with <code>data</code> and empty <code>operator_data</code>. See <code>erc777_sender</code>.</p>
<p>Emits a <code>Burned</code> event.</p>
<p>Requirements</p>
<ul>
<li>the caller must have at least <code>amount</code> tokens.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Destroys `amount` tokens from the caller's account, reducing the
    /// total supply.
    ///
    /// If a send hook is registered for the caller, the corresponding function
    /// will be called with `data` and empty `operator_data`. See `erc777_sender`.
    ///
    /// Emits a `Burned` event.
    ///
    /// Requirements
    ///
    /// - the caller must have at least `amount` tokens.
    fn burn(&amp;mut self, amount: E::Balance, data: Vec&lt;u8&gt;) -&gt; Result&lt;()&gt; {
        self._burn(Self::caller(), amount, data, Vec::default())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="authorize_operator"><a class="header" href="#authorize_operator">authorize_operator</a></h3>
<p>Make an account an operator of the caller.</p>
<p>See <code>is_operator_for</code>.</p>
<p>Emits an <code>AuthorizedOperator</code> event.</p>
<p>Requirements</p>
<ul>
<li><code>operator</code> cannot be calling address.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Make an account an operator of the caller.
    ///
    /// See `is_operator_for`.
    ///
    /// Emits an `AuthorizedOperator` event.
    ///
    /// Requirements
    ///
    /// - `operator` cannot be calling address.
    fn authorize_operator(&amp;mut self, operator: E::AccountId) {
        let caller = Self::caller();
        assert!(caller != operator, &quot;ERC777: authorizing self as operator&quot;);

        let key = (caller.clone(), operator.clone());

        if self.get().is_default_operator(&amp;operator) {
            self.get_mut().revoked_default_operators.take(&amp;key);
        } else {
            self.get_mut().operators.insert(key, ());
        }

        self.emit_event_authorized_operator(operator, caller);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="revoke_operator"><a class="header" href="#revoke_operator">revoke_operator</a></h3>
<p>Revoke an account's operator status for the caller.</p>
<p>See <code>is_operator_for</code> and <code>default_operators</code>.</p>
<p>Emits a <code>RevokedOperator</code> event.</p>
<p>Requirements</p>
<ul>
<li><code>operator</code> cannot be calling address.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Revoke an account's operator status for the caller.
    ///
    /// See `is_operator_for` and `default_operators`.
    ///
    /// Emits a `RevokedOperator` event.
    ///
    /// Requirements
    ///
    /// - `operator` cannot be calling address.
    fn revoke_operator(&amp;mut self, operator: E::AccountId) {
        let caller = Self::caller();
        assert!(caller != operator, &quot;ERC777: revoke self as operator&quot;);

        let key = (caller.clone(), operator.clone());

        if self.get().is_default_operator(&amp;operator) {
            self.get_mut().revoked_default_operators.insert(key, ());
        } else {
            self.get_mut().operators.take(&amp;key);
        }

        self.emit_event_revoked_operator(operator, caller);
    }

<span class="boring">}
</span></code></pre></pre>
<h3 id="operator_send"><a class="header" href="#operator_send">operator_send</a></h3>
<p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code>. The caller must
be an operator of <code>sender</code>.</p>
<p>If send or receive hooks are registered for <code>sender</code> and <code>recipient</code>,
the corresponding functions will be called with <code>data</code> and
<code>operator_data</code>. See <code>erc777_sender</code> and <code>erc777_recipient</code>.</p>
<p>Emits a <code>Sent</code> event.</p>
<p>Requirements</p>
<ul>
<li><code>sender</code> cannot be the zero address.</li>
<li><code>sender</code> must have at least <code>amount</code> tokens.</li>
<li>the caller must be an operator for <code>sender</code>.</li>
<li><code>recipient</code> cannot be the zero address.</li>
<li>if <code>recipient</code> is a contract, it must implement the <code>erc777_recipient</code> interface.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from `sender` to `recipient`. The caller must
    /// be an operator of `sender`.
    ///
    /// If send or receive hooks are registered for `sender` and `recipient`,
    /// the corresponding functions will be called with `data` and
    /// `operator_data`. See `erc777_sender` and `erc777_recipient`.
    ///
    /// Emits a `Sent` event.
    ///
    /// Requirements
    ///
    /// - `sender` cannot be the zero address.
    /// - `sender` must have at least `amount` tokens.
    /// - the caller must be an operator for `sender`.
    /// - `recipient` cannot be the zero address.
    /// - if `recipient` is a contract, it must implement the `erc777_recipient` interface.
    fn operator_send(
        &amp;mut self,
        sender: E::AccountId,
        recipient: E::AccountId,
        amount: E::Balance,
        data: Vec&lt;u8&gt;,
        operator_data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        assert!(
            self.get().is_operator_for(&amp;Self::caller(), &amp;sender),
            &quot;ERC777: caller is not an operator for holder&quot;
        );

        self._send(sender, recipient, amount, data, operator_data, true)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="operator_burn"><a class="header" href="#operator_burn">operator_burn</a></h3>
<p>Destroys <code>amount</code> tokens from <code>account</code>, reducing the total supply.
The caller must be an operator of <code>account</code>.</p>
<p>If a send hook is registered for <code>account</code>, the corresponding function
will be called with <code>data</code> and <code>operator_data</code>. See <code>erc777_sender</code>.</p>
<p>Emits a <code>Burned</code> event.</p>
<p>Requirements</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
<li><code>account</code> must have at least <code>amount</code> tokens.</li>
<li>the caller must be an operator for <code>account</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Destroys `amount` tokens from `account`, reducing the total supply.
    /// The caller must be an operator of `account`.
    ///
    /// If a send hook is registered for `account`, the corresponding function
    /// will be called with `data` and `operator_data`. See `erc777_sender`.
    ///
    /// Emits a `Burned` event.
    ///
    /// Requirements
    ///
    /// - `account` cannot be the zero address.
    /// - `account` must have at least `amount` tokens.
    /// - the caller must be an operator for `account`.
    fn operator_burn(
        &amp;mut self,
        account: E::AccountId,
        amount: E::Balance,
        data: Vec&lt;u8&gt;,
        operator_data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        assert!(
            self.get().is_operator_for(&amp;Self::caller(), &amp;account),
            &quot;ERC777: caller is not an operator for holder&quot;
        );

        self._burn(account, amount, data, operator_data)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approve-2"><a class="header" href="#approve-2">approve</a></h3>
<p>Sets <code>amount</code> as the allowance of <code>spender</code> over the caller's tokens.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>IMPORTANT: Beware that changing an allowance with this method brings the risk
that someone may use both the old and the new allowance by unfortunate
transaction ordering. One possible solution to mitigate this race
condition is to first reduce the spender's allowance to 0 and set the
desired value afterwards:
<a href="https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729">https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</a></p>
<p>Emits an <code>Approval</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Sets `amount` as the allowance of `spender` over the caller's tokens.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// IMPORTANT: Beware that changing an allowance with this method brings the risk
    /// that someone may use both the old and the new allowance by unfortunate
    /// transaction ordering. One possible solution to mitigate this race
    /// condition is to first reduce the spender's allowance to 0 and set the
    /// desired value afterwards:
    /// &lt;https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&gt;
    ///
    /// Emits an `Approval` event.
    fn approve(&amp;mut self, spender: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        self._approve(&amp;Self::caller(), spender, amount)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="transfer_from-2"><a class="header" href="#transfer_from-2">transfer_from</a></h3>
<p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the
allowance mechanism. <code>amount</code> is then deducted from the caller's
allowance.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from `sender` to `recipient` using the
    /// allowance mechanism. `amount` is then deducted from the caller's
    /// allowance.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// Emits a `Transfer` event.
    fn transfer_from(
        &amp;mut self,
        holder: &amp;E::AccountId,
        recipient: &amp;E::AccountId,
        amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        let caller = &amp;Self::caller();
        let null_account = &amp;E::AccountId::default();

        if recipient == null_account {
            return Err(Error::AccountIsZero)
        }

        let current_allowance = self.get().allowance(holder, caller);
        if current_allowance &lt; amount {
            return Err(Error::InsufficientAllowance)
        }

        let spender = Self::caller();

        self._call_tokens_to_send(
            &amp;spender,
            &amp;Some(&amp;holder),
            &amp;Some(&amp;recipient),
            &amp;amount,
            &amp;Vec::default(),
            &amp;Vec::default(),
        );

        self._approve(holder, caller, current_allowance - amount)?;

        self._move(
            &amp;spender,
            &amp;holder,
            &amp;recipient,
            &amp;amount,
            &amp;Vec::default(),
            &amp;Vec::default(),
        )?;

        self._call_tokens_received(
            &amp;spender,
            &amp;Some(&amp;holder),
            &amp;Some(&amp;recipient),
            &amp;amount,
            &amp;Vec::default(),
            &amp;Vec::default(),
            false,
        );

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-5"><a class="header" href="#message-for-querys-5">Message for Querys</a></h2>
<h3 id="name-2"><a class="header" href="#name-2">name</a></h3>
<p>Returns the name of the token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the name of the token.
    fn name(&amp;self) -&gt; String {
        self.get().name().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="symbol-2"><a class="header" href="#symbol-2">symbol</a></h3>
<p>Returns the symbol of the token, usually a shorter version of the name.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the symbol of the token, usually a shorter version of the name.
    fn symbol(&amp;self) -&gt; String {
        self.get().symbol().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="decimals-1"><a class="header" href="#decimals-1">decimals</a></h3>
<p>Returns the number of decimals used to get its user representation.
For example, if <code>decimals</code> equals <code>2</code>, a balance of <code>505</code> tokens should
be displayed to a user as <code>5,05</code> (<code>505 / 10 ** 2</code>).</p>
<p>Tokens usually opt for a value of 18, imitating the relationship between
Ether and Wei in ETH. This is the value <code>ERC20</code> uses, unless this function is
overridden;</p>
<blockquote>
<p>NOTE: This information is only used for <em>display</em> purposes: it in
no way affects any of the arithmetic of the contract</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the number of decimals used to get its user representation.
    /// For example, if `decimals` equals `2`, a balance of `505` tokens should
    /// be displayed to a user as `5,05` (`505 / 10 ** 2`).
    ///
    /// Tokens usually opt for a value of 18, imitating the relationship between
    /// Ether and Wei in ETH. This is the value `ERC20` uses, unless this function is
    /// overridden;
    ///
    /// NOTE: This information is only used for _display_ purposes: it in
    /// no way affects any of the arithmetic of the contract
    fn decimals(&amp;self) -&gt; u8 {
        self.get().decimals().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="granularity"><a class="header" href="#granularity">granularity</a></h3>
<p>Returns the smallest part of the token that is not divisible. This
means all token operations (creation, movement and destruction) must have
amounts that are a multiple of this number.</p>
<p>For most token contracts, this value will equal 1.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the smallest part of the token that is not divisible. This
    /// means all token operations (creation, movement and destruction) must have
    /// amounts that are a multiple of this number.
    ///
    /// For most token contracts, this value will equal 1.
    fn granularity(&amp;self) -&gt; E::Balance {
        E::Balance::from(1_u8)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="total_supply-1"><a class="header" href="#total_supply-1">total_supply</a></h3>
<p>Returns the amount of tokens in existence.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens in existence.
    fn total_supply(&amp;self) -&gt; E::Balance {
        self.get().total_supply()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance_of-2"><a class="header" href="#balance_of-2">balance_of</a></h3>
<p>Returns the amount of tokens owned by <code>account</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens owned by `account`.
    fn balance_of(&amp;self, account: &amp;E::AccountId) -&gt; E::Balance {
        self.get().balance_of(account)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_operator_for"><a class="header" href="#is_operator_for">is_operator_for</a></h3>
<p>Returns true if an account is an operator of <code>token_holder</code>.
Operators can send and burn tokens on behalf of their owners. All
accounts are their own operator.</p>
<p>See <code>operator_send</code> and <code>operator_burn</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns true if an account is an operator of `token_holder`.
    /// Operators can send and burn tokens on behalf of their owners. All
    /// accounts are their own operator.
    ///
    /// See `operator_send` and `operator_burn`.
    fn is_operator_for(
        &amp;self,
        operator: E::AccountId,
        token_holder: E::AccountId,
    ) -&gt; bool {
        self.get().is_operator_for(&amp;operator, &amp;token_holder)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="default_operators"><a class="header" href="#default_operators">default_operators</a></h3>
<p>Returns the list of default operators. These accounts are operators
for all token holders, even if <code>authorize_operator</code> was never called on
them.</p>
<p>This list is immutable, but individual holders may revoke these via
<code>revoke_operator</code>, in which case <code>is_operator_for</code> will return false.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the list of default operators. These accounts are operators
    /// for all token holders, even if `authorize_operator` was never called on
    /// them.
    ///
    /// This list is immutable, but individual holders may revoke these via
    /// `revoke_operator`, in which case `is_operator_for` will return false.
    fn default_operators(&amp;self) -&gt; Vec&lt;E::AccountId&gt; {
        self.get().default_operators_array.clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="allowance-1"><a class="header" href="#allowance-1">allowance</a></h3>
<p>Returns the remaining number of tokens that <code>spender</code> will be
allowed to spend on behalf of <code>owner</code> through <code>transfer_from</code>. This is
zero by default.</p>
<p>This value changes when <code>approve</code> or <code>transfer_from</code> are called.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the remaining number of tokens that `spender` will be
    /// allowed to spend on behalf of `owner` through `transfer_from`. This is
    /// zero by default.
    ///
    /// This value changes when `approve` or `transfer_from` are called.
    fn allowance(&amp;self, owner: &amp;E::AccountId, spender: &amp;E::AccountId) -&gt; E::Balance {
        self.get().allowance(owner, spender)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-5"><a class="header" href="#apis-5">APIs</a></h2>
<p>There are some api can help developer to add self-defined messages:</p>
<ul>
<li><code>_mint</code></li>
<li><code>_mint_required_reception_ack</code></li>
<li><code>_burn</code></li>
</ul>
<h3 id="_mint-2"><a class="header" href="#_mint-2">_mint</a></h3>
<p>Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing
the total supply.</p>
<p>If a send hook is registered for <code>account</code>, the corresponding function
will be called with <code>operator</code>, <code>data</code> and <code>operator_data</code>.</p>
<p>See <code>erc777_sender</code> and <code>erc777_recipient</code>.</p>
<p>Emits <code>Minted</code> and <code>Transfer</code> events.</p>
<p>Requirements</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
<li>if <code>account</code> is a contract, it must implement the <code>erc777_recipient</code> interface.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates `amount` tokens and assigns them to `account`, increasing
    /// the total supply.
    ///
    /// If a send hook is registered for `account`, the corresponding function
    /// will be called with `operator`, `data` and `operator_data`.
    ///
    /// See `erc777_sender` and `erc777_recipient`.
    ///
    /// Emits `Minted` and `Transfer` events.
    ///
    /// Requirements
    ///
    /// - `account` cannot be the zero address.
    /// - if `account` is a contract, it must implement the `erc777_recipient` interface.
    fn _mint(
        &amp;mut self,
        account: E::AccountId,
        amount: E::Balance,
        user_data: Vec&lt;u8&gt;,
        operator_data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        self._mint_required_reception_ack(account, amount, user_data, operator_data, true)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_mint_required_reception_ack"><a class="header" href="#_mint_required_reception_ack">_mint_required_reception_ack</a></h3>
<p>Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing
the total supply.</p>
<p>If <code>requireReceptionAck</code> is set to true, and if a send hook is
registered for <code>account</code>, the corresponding function will be called with
<code>operator</code>, <code>data</code> and <code>operator_data</code>.</p>
<p>See <code>erc777_sender</code> and <code>erc777_recipient</code>.</p>
<p>Emits <code>Minted</code> and <code>Transfer</code> events.</p>
<p>Requirements</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
<li>if <code>account</code> is a contract, it must implement the <code>erc777_recipient</code> interface.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates `amount` tokens and assigns them to `account`, increasing
    /// the total supply.
    ///
    /// If `requireReceptionAck` is set to true, and if a send hook is
    /// registered for `account`, the corresponding function will be called with
    /// `operator`, `data` and `operator_data`.
    ///
    /// See `erc777_sender` and `erc777_recipient`.
    ///
    /// Emits `Minted` and `Transfer` events.
    ///
    /// Requirements
    ///
    /// - `account` cannot be the zero address.
    /// - if `account` is a contract, it must implement the `erc777_recipient` interface.
    fn _mint_required_reception_ack(
        &amp;mut self,
        account: E::AccountId,
        amount: E::Balance,
        user_data: Vec&lt;u8&gt;,
        operator_data: Vec&lt;u8&gt;,
        required_reception_ack: bool,
    ) -&gt; Result&lt;()&gt; {
        let null_account = E::AccountId::default();

        if account == null_account {
            return Err(Error::AccountIsZero)
        }

        let operator = Self::caller();

        self._before_token_transfer(&amp;operator, &amp;None, &amp;Some(&amp;account), &amp;amount)?;

        // Update state variables
        let current_total = self.get().total_supply();
        let current_balance = self.get().balance_of(&amp;account);

        self.get_mut().set_total_supply(current_total + amount);
        self.get_mut()
            .set_balance(&amp;account, current_balance + amount);

        self._call_tokens_received(
            &amp;operator,
            &amp;None,
            &amp;Some(&amp;account),
            &amp;amount,
            &amp;user_data,
            &amp;operator_data,
            required_reception_ack,
        );

        self.emit_event_minted(
            operator,
            account.clone(),
            amount,
            user_data,
            operator_data,
        );
        self.emit_event_transfer(None, Some(account), amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_burn-2"><a class="header" href="#_burn-2">_burn</a></h3>
<p>Burn tokens</p>
<p>Params:</p>
<ul>
<li>from address token holder address</li>
<li>amount uint256 amount of tokens to burn</li>
<li>data bytes extra information provided by the token holder</li>
<li>operator_data bytes extra information provided by the operator (if any)</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Burn tokens
    /// 
    /// Params:
    /// 
    /// - from address token holder address
    /// - amount uint256 amount of tokens to burn
    /// - data bytes extra information provided by the token holder
    /// - operator_data bytes extra information provided by the operator (if any)
    fn _burn(
        &amp;mut self,
        from: E::AccountId,
        amount: E::Balance,
        data: Vec&lt;u8&gt;,
        operator_data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        let null_account = E::AccountId::default();

        assert!(from != null_account, &quot;ERC777: burn from the zero address&quot;);

        let operator = Self::caller();

        self._call_tokens_to_send(
            &amp;operator,
            &amp;Some(&amp;from),
            &amp;None,
            &amp;amount,
            &amp;data,
            &amp;operator_data,
        );

        self._before_token_transfer(&amp;operator, &amp;Some(&amp;from), &amp;None, &amp;amount)?;

        // Update state variables
        let from_balance = self.get().balance_of(&amp;from);
        assert!(
            from_balance &gt;= amount,
            &quot;ERC777: burn amount exceeds balance&quot;
        );
        self.get_mut().set_balance(&amp;from, from_balance - amount);

        let current_total = self.get().total_supply();
        self.get_mut().set_total_supply(current_total - amount);

        self.emit_event_burned(operator, from.clone(), amount, data, operator_data);
        self.emit_event_transfer(Some(from), None, amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="hooks-2"><a class="header" href="#hooks-2">Hooks</a></h2>
<h3 id="_before_token_transfer-2"><a class="header" href="#_before_token_transfer-2">_before_token_transfer</a></h3>
<p>Hook that is called before any token transfer. This includes
calls to <code>send</code>, <code>transfer</code>, <code>operator_send</code>, minting and burning.</p>
<p>Calling conditions:</p>
<ul>
<li>when <code>from</code> and <code>to</code> are both non-zero, <code>amount</code> of <code>from</code>'s tokens
will be to transferred to <code>to</code>.</li>
<li>when <code>from</code> is zero, <code>amount</code> tokens will be minted for <code>to</code>.</li>
<li>when <code>to</code> is zero, <code>amount</code> of <code>from</code>'s tokens will be burned.</li>
<li><code>from</code> and <code>to</code> are never both zero.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Hook that is called before any token transfer. This includes
    /// calls to `send`, `transfer`, `operator_send`, minting and burning.
    ///
    /// Calling conditions:
    ///
    /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    /// will be to transferred to `to`.
    /// - when `from` is zero, `amount` tokens will be minted for `to`.
    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.
    /// - `from` and `to` are never both zero.
    fn _before_token_transfer(
        &amp;mut self,
        _operator: &amp;E::AccountId,
        _from: &amp;Option&lt;&amp;E::AccountId&gt;,
        _to: &amp;Option&lt;&amp;E::AccountId&gt;,
        _amount: &amp;E::Balance,
    ) -&gt; Result&lt;()&gt; {
        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-5"><a class="header" href="#events-5">Events</a></h2>
<h3 id="transfer-4"><a class="header" href="#transfer-4">Transfer</a></h3>
<p>Event emitted when a token transfer occurs.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approval-2"><a class="header" href="#approval-2">Approval</a></h3>
<p>Event emitted when an approval occurs that <code>spender</code> is allowed to
withdraw up to the amount of <code>value</code> tokens from <code>owner</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when an approval occurs that `spender` is allowed to 
    /// withdraw up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="sent"><a class="header" href="#sent">Sent</a></h3>
<p>Indicate a send of <code>amount</code> of tokens from the <code>from</code> address to the <code>to</code>
address by the <code>operator</code> address.</p>
<blockquote>
<p>NOTE: This event MUST NOT be emitted outside of a send or an ERC-20 transfer process.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Indicate a send of `amount` of tokens from the `from` address to the `to`
    /// address by the `operator` address.
    /// 
    /// NOTE: This event MUST NOT be emitted outside of a send or an ERC-20 transfer process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Sent {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: AccountId,
        #[ink(topic)]
        pub to: AccountId,
        pub amount: Balance,
        pub data: Vec&lt;u8&gt;,
        pub operator_data: Vec&lt;u8&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="minted"><a class="header" href="#minted">Minted</a></h3>
<p>Indicate the minting of <code>amount</code> of tokens to the <code>to</code> address by
the <code>operator</code> address.</p>
<blockquote>
<p>NOTE: This event MUST NOT be emitted outside of a mint process.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Indicate the minting of `amount` of tokens to the `to` address by
    /// the `operator` address.
    ///
    /// NOTE: This event MUST NOT be emitted outside of a mint process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Minted {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub to: AccountId,
        pub amount: Balance,
        pub data: Vec&lt;u8&gt;,
        pub operator_data: Vec&lt;u8&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="burned"><a class="header" href="#burned">Burned</a></h3>
<p>Indicate the burning of <code>amount</code> of tokens from the <code>from</code> address
by the <code>operator</code> address.</p>
<blockquote>
<p>NOTE: This event MUST NOT be emitted outside of a burn process.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Indicate the burning of `amount` of tokens from the `from` address
    /// by the `operator` address.
    /// 
    /// NOTE: This event MUST NOT be emitted outside of a burn process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct Burned {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: AccountId,
        pub amount: Balance,
        pub data: Vec&lt;u8&gt;,
        pub operator_data: Vec&lt;u8&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="authorizedoperator"><a class="header" href="#authorizedoperator">AuthorizedOperator</a></h3>
<p>Indicates the authorization of <code>operator</code> as an operator for <code>holder</code>.</p>
<blockquote>
<p>NOTE: This event MUST NOT be emitted outside of an operator authorization process.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Indicates the authorization of `operator` as an operator for `holder`.
    /// 
    /// NOTE: This event MUST NOT be emitted outside of an operator authorization process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct AuthorizedOperator {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub token_holder: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="revokedoperator"><a class="header" href="#revokedoperator">RevokedOperator</a></h3>
<p>Indicates the revocation of <code>operator</code> as an operator for <code>holder</code>.</p>
<blockquote>
<p>NOTE: This event MUST NOT be emitted outside of an operator revocation process.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Indicates the revocation of `operator` as an operator for `holder`.
    /// 
    /// NOTE: This event MUST NOT be emitted outside of an operator revocation process.
    #[ink(event)]
    #[metis(erc777)]
    pub struct RevokedOperator {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub token_holder: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc1155"><a class="header" href="#erc1155">ERC1155</a></h1>
<p>Details of ERC1155 can be found in <a href="https://eips.ethereum.org/EIPS/eip-1155">ERC1155</a>.</p>
<h2 id="usage-7"><a class="header" href="#usage-7">Usage</a></h2>
<p>To make a new erc1155-like token, we should import erc1155 at first:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg_attr(not(feature = &quot;std&quot;), no_std)]

<span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    pub use erc1155::{
        Error,
        Result,
        TokenId,
    };
    use metis_erc1155 as erc1155;
    use metis_lang::{
        import,
        metis,
    };

    #[ink(storage)]
    #[import(erc1155)]
    pub struct Erc1155 {
        erc1155: erc1155::Data&lt;Erc1155&gt;,
    }

    impl erc1155::Impl&lt;Erc1155&gt; for Erc1155 {}
}
<span class="boring">}
</span></code></pre></pre>
<p>Then add the event for erc1155:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct TransferSingle {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub id: TokenId,
        pub value: Balance,
    }

    /// Equivalent to multiple `TransferSingle` events, where `operator`, `from` and `to` are the same for all
    /// transfers.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct TransferBatch {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub id: Vec&lt;TokenId&gt;,
        pub value: Vec&lt;Balance&gt;,
    }

    /// Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct ApprovalForAll {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub operator: AccountId,
        pub approved: bool,
    }

    /// Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
    ///
    /// If an `URI` event was emitted for `id`, the standard
    /// https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
    /// returned by `uri`.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct Url {
        pub value: String,
        #[ink(topic)]
        pub id: TokenId,
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Erc1155 {
        #[ink(constructor)]
        pub fn new(url: String) -&gt; Self {
            let mut instance = Self {
                erc1155: erc1155::Data::new(),
            };

            erc1155::Impl::init(&amp;mut instance, url);
            instance
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the messages for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Erc1155 {
        /// Returns the URI for token type `id`.
        ///
        /// This implementation returns the same URI for *all* token types. It relies
        /// on the token type ID substitution mechanism
        /// https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
        ///
        /// Clients calling this function must replace the `\{id\}` substring with the
        /// actual token type ID.
        #[ink(message)]
        pub fn url(&amp;self, id: TokenId) -&gt; String {
            erc1155::Impl::url(self, id)
        }

        /// Returns the amount of tokens of token type `id` owned by `account`.
        ///
        /// Requirements:
        ///
        /// - `account` cannot be the zero address.
        #[ink(message)]
        pub fn balance_of(&amp;self, account: &amp;AccountId, id: &amp;TokenId) -&gt; Balance {
            erc1155::Impl::balance_of(self, account, id)
        }

        /// Batched version of balance_of
        ///
        /// Requirements:
        ///
        /// - `accounts` and `ids` must have the same length.
        #[ink(message)]
        pub fn balance_of_batch(
            &amp;self,
            accounts: Vec&lt;AccountId&gt;,
            ids: Vec&lt;TokenId&gt;,
        ) -&gt; Vec&lt;Balance&gt; {
            erc1155::Impl::balance_of_batch(self, accounts, ids)
        }

        /// Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
        /// 
        /// Emits an `ApprovalForAll` event.
        /// 
        /// Requirements:
        /// 
        /// - `operator` cannot be the caller.
        #[ink(message)]
        pub fn set_approval_for_all(&amp;mut self, operator: AccountId, approved: bool) {
            erc1155::Impl::set_approval_for_all(self, operator, approved)
        }

        /// Returns true if `operator` is approved to transfer ``account``'s tokens.
        /// 
        /// See `set_approval_for_all`.
        #[ink(message)]
        pub fn is_approved_for_all(
            &amp;self,
            account: &amp;AccountId,
            operator: &amp;AccountId,
        ) -&gt; bool {
            erc1155::Impl::is_approved_for_all(self, account, operator)
        }

        /// Transfers `amount` tokens of token type `id` from `from` to `to`.
        ///
        /// Emits a `TransferSingle` event.
        ///
        /// Requirements:
        ///
        /// - `to` cannot be the zero address.
        /// - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via `set_approval_for_all`.
        /// - `from` must have a balance of tokens of type `id` of at least `amount`.
        /// - If `to` refers to a smart contract, it must implement `on_erc1155_received` and return the
        ///   acceptance magic value.
        #[ink(message)]
        pub fn safe_transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            id: TokenId,
            amount: Balance,
            data: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            erc1155::Impl::safe_transfer_from(self, from, to, id, amount, data)
        }

        /// Batched version of the `safe_transfer_from`
        ///
        /// Emits a `TransferBatch` event.
        ///
        /// Requirements:
        ///
        /// - `ids` and `amounts` must have the same length.
        /// - If `to` refers to a smart contract, it must implement `on_erc1155_batch_received` and return the
        ///   acceptance magic value.
        #[ink(message)]
        pub fn safe_batch_transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            ids: Vec&lt;TokenId&gt;,
            amounts: Vec&lt;Balance&gt;,
            data: Vec&lt;u8&gt;,
        ) -&gt; Result&lt;()&gt; {
            erc1155::Impl::safe_batch_transfer_from(self, from, to, ids, amounts, data)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<h2 id="messages-for-txs-6"><a class="header" href="#messages-for-txs-6">Messages for Txs</a></h2>
<h3 id="set_approval_for_all-1"><a class="header" href="#set_approval_for_all-1">set_approval_for_all</a></h3>
<p>Grants or revokes permission to <code>operator</code> to transfer the caller's tokens, according to <code>approved</code>,</p>
<p>Emits an <code>ApprovalForAll</code> event.</p>
<p>Requirements:</p>
<ul>
<li><code>operator</code> cannot be the caller.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,
    /// 
    /// Emits an `ApprovalForAll` event.
    /// 
    /// Requirements:
    /// 
    /// - `operator` cannot be the caller.
    fn set_approval_for_all(&amp;mut self, operator: E::AccountId, approved: bool) {
        let caller = Self::caller();

        assert!(
            caller != operator,
            &quot;ERC1155: setting approval status for self&quot;
        );

        self.get_mut()
            .set_approval_for_all(caller.clone(), operator.clone(), approved);
        self.emit_event_approval_for_all(caller, operator, approved);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="safe_transfer_from-1"><a class="header" href="#safe_transfer_from-1">safe_transfer_from</a></h3>
<p>Transfers <code>amount</code> tokens of token type <code>id</code> from <code>from</code> to <code>to</code>.</p>
<p>Emits a <code>TransferSingle</code> event.</p>
<p>Requirements:</p>
<ul>
<li><code>to</code> cannot be the zero address.</li>
<li>If the caller is not <code>from</code>, it must be have been approved to spend <code>from</code>'s tokens via <code>set_approval_for_all</code>.</li>
<li><code>from</code> must have a balance of tokens of type <code>id</code> of at least <code>amount</code>.</li>
<li>If <code>to</code> refers to a smart contract, it must implement <code>on_erc1155_received</code> and return the acceptance magic value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Transfers `amount` tokens of token type `id` from `from` to `to`.
    ///
    /// Emits a `TransferSingle` event.
    ///
    /// Requirements:
    ///
    /// - `to` cannot be the zero address.
    /// - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via `set_approval_for_all`.
    /// - `from` must have a balance of tokens of type `id` of at least `amount`.
    /// - If `to` refers to a smart contract, it must implement `on_erc1155_received` and return the
    ///   acceptance magic value.
    fn safe_transfer_from(
        &amp;mut self,
        from: E::AccountId,
        to: E::AccountId,
        id: TokenId,
        amount: E::Balance,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        let caller = Self::caller();
        assert!(
            from == caller || self.is_approved_for_all(&amp;from, &amp;caller),
            &quot;ERC1155: caller is not owner nor approved&quot;
        );

        self._safe_transfer_from(from, to, id, amount, data)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="safe_batch_transfer_from"><a class="header" href="#safe_batch_transfer_from">safe_batch_transfer_from</a></h3>
<p>Batched version of the <code>safe_transfer_from</code></p>
<p>Emits a <code>TransferBatch</code> event.</p>
<p>Requirements:</p>
<ul>
<li><code>ids</code> and <code>amounts</code> must have the same length.</li>
<li>If <code>to</code> refers to a smart contract, it must implement <code>on_erc1155_batch_received</code> and return the acceptance magic value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Batched version of the `safe_transfer_from`
    ///
    /// Emits a `TransferBatch` event.
    ///
    /// Requirements:
    ///
    /// - `ids` and `amounts` must have the same length.
    /// - If `to` refers to a smart contract, it must implement `on_erc1155_batch_received` and return the
    ///   acceptance magic value.
    fn safe_batch_transfer_from(
        &amp;mut self,
        from: E::AccountId,
        to: E::AccountId,
        id: Vec&lt;TokenId&gt;,
        amount: Vec&lt;E::Balance&gt;,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        let caller = Self::caller();
        assert!(
            from == caller || self.is_approved_for_all(&amp;from, &amp;caller),
            &quot;ERC1155: transfer caller is not owner nor approved&quot;
        );

        self._safe_batch_transfer_from(from, to, id, amount, data)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-6"><a class="header" href="#message-for-querys-6">Message for Querys</a></h2>
<h3 id="url"><a class="header" href="#url">url</a></h3>
<p>Returns the URI for token type <code>id</code>.</p>
<p>This implementation returns the same URI for <em>all</em> token types. It relies on the token type ID substitution mechanism
<a href="https://eips.ethereum.org/EIPS/eip-1155#metadata">defined in the EIP</a>.</p>
<p>Clients calling this function must replace the <code>\{id\}</code> substring with the actual token type ID.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the URI for token type `id`.
    ///
    /// This implementation returns the same URI for *all* token types. It relies
    /// on the token type ID substitution mechanism
    /// https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].
    ///
    /// Clients calling this function must replace the `\{id\}` substring with the
    /// actual token type ID.
    fn url(&amp;self, _id: TokenId) -&gt; String {
        self.get().get_url()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance_of-3"><a class="header" href="#balance_of-3">balance_of</a></h3>
<p>Returns the amount of tokens of token type <code>id</code> owned by <code>account</code>.</p>
<p>Requirements:</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens of token type `id` owned by `account`.
    ///
    /// Requirements:
    ///
    /// - `account` cannot be the zero address.
    fn balance_of(&amp;self, account: &amp;E::AccountId, id: &amp;TokenId) -&gt; E::Balance {
        assert!(
            *account != E::AccountId::default(),
            &quot;ERC1155: balance query for the zero address&quot;
        );

        self.get().balance_of(id, account)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance_of_batch"><a class="header" href="#balance_of_batch">balance_of_batch</a></h3>
<p>Batched version of balance_of</p>
<p>Requirements:</p>
<ul>
<li><code>accounts</code> and <code>ids</code> must have the same length.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Batched version of balance_of
    ///
    /// Requirements:
    ///
    /// - `accounts` and `ids` must have the same length.
    fn balance_of_batch(
        &amp;self,
        accounts: Vec&lt;E::AccountId&gt;,
        ids: Vec&lt;TokenId&gt;,
    ) -&gt; Vec&lt;E::Balance&gt; {
        assert!(
            accounts.len() == ids.len(),
            &quot;ERC1155: accounts and ids length mismatch&quot;
        );

        (0..accounts.len())
            .collect::&lt;Vec&lt;_&gt;&gt;()
            .iter()
            .map(|idx| {
                self.balance_of(accounts.get(*idx).unwrap(), ids.get(*idx).unwrap())
            })
            .collect()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="is_approved_for_all-1"><a class="header" href="#is_approved_for_all-1">is_approved_for_all</a></h3>
<p>Returns true if <code>operator</code> is approved to transfer <code>account</code>'s tokens.</p>
<p>See <code>set_approval_for_all</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns true if `operator` is approved to transfer ``account``'s tokens.
    /// 
    /// See `set_approval_for_all`.
    fn is_approved_for_all(
        &amp;self,
        account: &amp;E::AccountId,
        operator: &amp;E::AccountId,
    ) -&gt; bool {
        self.get().is_approved_for_all(account, operator)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-6"><a class="header" href="#apis-6">APIs</a></h2>
<h3 id="_mint-3"><a class="header" href="#_mint-3">_mint</a></h3>
<p>Creates <code>amount</code> tokens of token type <code>id</code>, and assigns them to <code>account</code>.</p>
<p>Emits a <code>TransferSingle</code> event.</p>
<p>Requirements:</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
<li>If <code>account</code> refers to a smart contract, it must implement <code>on_erc1155_received</code> and return the acceptance magic value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates `amount` tokens of token type `id`, and assigns them to `account`.
    ///
    /// Emits a `TransferSingle` event.
    ///
    /// Requirements:
    ///
    /// - `account` cannot be the zero address.
    /// - If `account` refers to a smart contract, it must implement `on_erc1155_received` and return the
    ///   acceptance magic value.
    fn _mint(
        &amp;mut self,
        account: E::AccountId,
        id: TokenId,
        amount: E::Balance,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        if account == E::AccountId::default() {
            return Err(Error::AccountIsZero)
        }

        let operator = Self::caller();

        self._before_token_transfer(
            &amp;operator,
            &amp;None,
            &amp;Some(&amp;account),
            &amp;vec![id],
            &amp;vec![amount],
            &amp;data,
        )?;

        self.get_mut().add_balance(&amp;account, &amp;id, amount);
        self._do_safe_transfer_acceptance_check(
            &amp;operator, &amp;None, &amp;account, &amp;id, &amp;amount, &amp;data,
        );

        self.emit_event_transfer_single(operator, None, Some(account), id, amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_mint_batch"><a class="header" href="#_mint_batch">_mint_batch</a></h3>
<p>Batched version of <code>_mint</code>.</p>
<p>Requirements:</p>
<ul>
<li><code>ids</code> and <code>amounts</code> must have the same length.</li>
<li>If <code>to</code> refers to a smart contract, it must implement <code>on_erc1155_batch_received</code> and return the acceptance magic value.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Batched version of `_mint`.
    ///
    /// Requirements:
    ///
    /// - `ids` and `amounts` must have the same length.
    /// - If `to` refers to a smart contract, it must implement `on_erc1155_batch_received` and return the
    ///   acceptance magic value.
    fn _mint_batch(
        &amp;mut self,
        to: E::AccountId,
        ids: Vec&lt;TokenId&gt;,
        amounts: Vec&lt;E::Balance&gt;,
        data: Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        assert!(
            ids.len() == amounts.len(),
            &quot;ERC1155: ids and amounts length mismatch&quot;
        );

        if to == E::AccountId::default() {
            return Err(Error::AccountIsZero)
        }

        let operator = Self::caller();

        self._before_token_transfer(&amp;operator, &amp;None, &amp;Some(&amp;to), &amp;ids, &amp;amounts, &amp;data)?;

        for i in 0..ids.len() {
            let id = ids[i];
            let amount = amounts[i];

            self.get_mut().add_balance(&amp;to, &amp;id, amount);
        }

        self._do_safe_batch_transfer_acceptance_check(
            &amp;operator, &amp;None, &amp;to, &amp;ids, &amp;amounts, &amp;data,
        );
        self.emit_event_transfer_batch(operator, None, Some(to), ids, amounts);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_burn-3"><a class="header" href="#_burn-3">_burn</a></h3>
<p>Destroys <code>amount</code> tokens of token type <code>id</code> from <code>account</code></p>
<p>Requirements:</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
<li><code>account</code> must have at least <code>amount</code> tokens of token type <code>id</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Destroys `amount` tokens of token type `id` from `account`
    ///
    /// Requirements:
    ///
    /// - `account` cannot be the zero address.
    /// - `account` must have at least `amount` tokens of token type `id`.
    fn _burn(
        &amp;mut self,
        account: E::AccountId,
        id: TokenId,
        amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        if account == E::AccountId::default() {
            return Err(Error::AccountIsZero)
        }

        let operator = Self::caller();

        self._before_token_transfer(
            &amp;operator,
            &amp;Some(&amp;account),
            &amp;None,
            &amp;vec![id],
            &amp;vec![amount],
            &amp;Vec::&lt;u8&gt;::default(),
        )?;

        let account_balance = self.get().balance_of(&amp;id, &amp;account);
        assert!(
            account_balance &gt;= amount,
            &quot;ERC1155: burn amount exceeds balance&quot;
        );
        self.get_mut()
            .set_balance(&amp;account, &amp;id, account_balance - amount);

        self.emit_event_transfer_single(operator, Some(account), None, id, amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_burn_batch"><a class="header" href="#_burn_batch">_burn_batch</a></h3>
<p>Batched version of <code>_burn</code>.</p>
<p>Requirements:</p>
<ul>
<li><code>ids</code> and <code>amounts</code> must have the same length.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Batched version of `_burn`.
    ///
    /// Requirements:
    ///
    /// - `ids` and `amounts` must have the same length.
    fn _burn_batch(
        &amp;mut self,
        account: E::AccountId,
        ids: Vec&lt;TokenId&gt;,
        amounts: Vec&lt;E::Balance&gt;,
    ) -&gt; Result&lt;()&gt; {
        assert!(
            ids.len() == amounts.len(),
            &quot;ERC1155: ids and amounts length mismatch&quot;
        );

        if account == E::AccountId::default() {
            return Err(Error::AccountIsZero)
        }

        let operator = Self::caller();

        self._before_token_transfer(
            &amp;operator,
            &amp;Some(&amp;account),
            &amp;None,
            &amp;ids,
            &amp;amounts,
            &amp;Vec::&lt;u8&gt;::default(),
        )?;

        for i in 0..ids.len() {
            let id = ids[i];
            let amount = amounts[i];

            let account_balance = self.get().balance_of(&amp;id, &amp;account);
            assert!(
                account_balance &gt;= amount,
                &quot;ERC1155: burn amount exceeds balance&quot;
            );
            self.get_mut()
                .set_balance(&amp;account, &amp;id, account_balance - amount);
        }

        self.emit_event_transfer_batch(operator, Some(account), None, ids, amounts);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="hooks-3"><a class="header" href="#hooks-3">Hooks</a></h2>
<h3 id="_before_token_transfer-3"><a class="header" href="#_before_token_transfer-3">_before_token_transfer</a></h3>
<p>Hook that is called before any token transfer. This includes minting
and burning, as well as batched variants.</p>
<p>The same hook is called on both single and batched variants. For single
transfers, the length of the <code>id</code> and <code>amount</code> arrays will be 1.</p>
<p>Calling conditions (for each <code>id</code> and <code>amount</code> pair):</p>
<ul>
<li>When <code>from</code> and <code>to</code> are both non-zero, <code>amount</code> of <code>from</code>'s tokens of token type <code>id</code> will be  transferred to <code>to</code>.</li>
<li>When <code>from</code> is zero, <code>amount</code> tokens of token type <code>id</code> will be minted for <code>to</code>.</li>
<li>when <code>to</code> is zero, <code>amount</code> of <code>from</code>'s tokens of token type <code>id</code> will be burned.</li>
<li><code>from</code> and <code>to</code> are never both zero.</li>
<li><code>ids</code> and <code>amounts</code> have the same, non-zero length.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Hook that is called before any token transfer. This includes minting
    /// and burning, as well as batched variants.
    ///
    /// The same hook is called on both single and batched variants. For single
    /// transfers, the length of the `id` and `amount` arrays will be 1.
    ///
    /// Calling conditions (for each `id` and `amount` pair):
    ///
    /// - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    /// of token type `id` will be  transferred to `to`.
    /// - When `from` is zero, `amount` tokens of token type `id` will be minted
    /// for `to`.
    /// - when `to` is zero, `amount` of ``from``'s tokens of token type `id`
    /// will be burned.
    /// - `from` and `to` are never both zero.
    /// - `ids` and `amounts` have the same, non-zero length.
    fn _before_token_transfer(
        &amp;mut self,
        _operator: &amp;E::AccountId,
        _from: &amp;Option&lt;&amp;E::AccountId&gt;,
        _to: &amp;Option&lt;&amp;E::AccountId&gt;,
        _ids: &amp;Vec&lt;TokenId&gt;,
        _amounts: &amp;Vec&lt;E::Balance&gt;,
        _data: &amp;Vec&lt;u8&gt;,
    ) -&gt; Result&lt;()&gt; {
        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-6"><a class="header" href="#events-6">Events</a></h2>
<h3 id="transfersingle"><a class="header" href="#transfersingle">TransferSingle</a></h3>
<p>Emitted when <code>value</code> tokens of token type <code>id</code> are transferred
from <code>from</code> to <code>to</code> by <code>operator</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `value` tokens of token type `id` are transferred
    /// from `from` to `to` by `operator`.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct TransferSingle {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub id: TokenId,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="transferbatch"><a class="header" href="#transferbatch">TransferBatch</a></h3>
<p>Equivalent to multiple <code>TransferSingle</code> events, where <code>operator</code>,
<code>from</code> and <code>to</code> are the same for all transfers.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Equivalent to multiple `TransferSingle` events, where `operator`,
    /// `from` and `to` are the same for all transfers.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct TransferBatch {
        #[ink(topic)]
        pub operator: AccountId,
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub id: Vec&lt;TokenId&gt;,
        pub value: Vec&lt;Balance&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approvalforall-1"><a class="header" href="#approvalforall-1">ApprovalForAll</a></h3>
<p>Emitted when <code>owner</code> enables or disables (<code>approved</code>) <code>operator</code> to manage all of its assets.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when `owner` enables or disables (`approved`)
    /// `operator` to manage all of its assets.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct ApprovalForAll {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub operator: AccountId,
        pub approved: bool,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="url-1"><a class="header" href="#url-1">Url</a></h3>
<p>Emitted when the URI for token type <code>id</code> changes to <code>value</code>, if it is a non-programmatic URI.</p>
<p>If an <code>URI</code> event was emitted for <code>id</code>, the standard
<a href="https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions">eip-1155#metadata-extensions</a> that <code>value</code> will equal the value
returned by <code>uri</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.
    ///
    /// If an `URI` event was emitted for `id`, the standard
    /// https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value
    /// returned by `uri`.
    #[ink(event)]
    #[metis(erc1155)]
    pub struct Url {
        pub value: String,
        #[ink(topic)]
        pub id: TokenId,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities"><a class="header" href="#utilities">Utilities</a></h1>
<p>Some utilities components:</p>
<ul>
<li><a href="./utilities/escrow.html">Escrow</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escrow"><a class="header" href="#escrow">Escrow</a></h1>
<p>Base escrow contract, holds funds designated for a payee until they
withdraw them.</p>
<p>Intended usage: This contract (and derived escrow contracts) should be a
standalone contract, that only interacts with the contract that instantiated
it. That way, it is guaranteed that all Ether will be handled according to
the <code>Escrow</code> rules, and there is no need to check for payable functions or
transfers in the inheritance tree. The contract that uses the escrow as its
payment method should be its owner, and provide public methods redirecting
to the escrow's deposit and withdraw.</p>
<h2 id="usage-8"><a class="header" href="#usage-8">Usage</a></h2>
<p>To use <code>Escrow</code> component, should import escrow, in most cases it also need a access control component, the example we use ownable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod mock {
    use metis_escrow as escrow;
    use metis_lang::{
        import,
        metis,
    };
    use metis_ownable as ownable;

    #[ink(storage)]
    #[import(ownable, escrow)]
    pub struct Escrow {
        ownable: ownable::Data&lt;Escrow&gt;,
        escrow: escrow::Data&lt;Escrow&gt;,
    }

    // others
}
<span class="boring">}
</span></code></pre></pre>
<p>then define the events:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when payee deposit amount
    #[ink(event)]
    #[metis(escrow)]
    pub struct Deposited {
        #[ink(topic)]
        pub payee: AccountId,
        pub amount: Balance,
    }

    /// Event emitted when payee withdraw
    #[ink(event)]
    #[metis(escrow)]
    pub struct Withdrawn {
        #[ink(topic)]
        pub payee: AccountId,
        pub amount: Balance,
    }

    /// Event emitted when Owner AccountId Transferred
    #[ink(event)]
    #[metis(ownable)]
    pub struct OwnershipTransferred {
        /// previous owner account id
        #[ink(topic)]
        previous_owner: Option&lt;AccountId&gt;,
        /// new owner account id
        #[ink(topic)]
        new_owner: Option&lt;AccountId&gt;,
    }
<span class="boring">}
</span></code></pre></pre>
<p><code>OwnershipTransferred</code> event is for ownable component.</p>
<p>Add the constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[ink(constructor)]
        pub fn new() -&gt; Self {
            let mut instance = Self {
                ownable: ownable::Data::new(),
                escrow: escrow::Data::new(),
            };

            ownable::Impl::init(&amp;mut instance);

            // escrow not need init

            instance
        }

<span class="boring">}
</span></code></pre></pre>
<p>The messages, not forget the <code>payable</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        /// return the deposits of account
        #[ink(message)]
        pub fn deposits_of(&amp;self, payee: AccountId) -&gt; Balance {
            escrow::Impl::deposits_of(self, &amp;payee)
        }

        /// deposit by payee, the pay value is the amount to transfer
        #[ink(message, payable)]
        pub fn deposit(&amp;mut self, payee: AccountId) {
            ownable::Impl::ensure_caller_is_owner(self);
            escrow::Impl::deposit(self, payee)
        }

        // withdraw all deposits from the payee
        #[ink(message)]
        pub fn withdraw(&amp;mut self, payee: AccountId) {
            ownable::Impl::ensure_caller_is_owner(self);
            escrow::Impl::withdraw(self, payee)
        }
<span class="boring">}
</span></code></pre></pre>
<p>In most cases, the owner of escrow contract should be another contract, the contract call the <code>deposit</code> and <code>withdraw</code> from its contract.</p>
<p>To call the escrow contract, developer can use the <a href="utilities/%5B../../../crates/components/utils/stub/src/lib.rs%5D(https://github.com/patractlabs/metis/blob/master/crates/components/utils/escrow/stub/src/lib.rs)">stub</a> of the escrow</p>
<h2 id="module-3"><a class="header" href="#module-3">Module</a></h2>
<p>the deposits is the map of payee to balance:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The Data of escrow component
#[cfg_attr(feature = &quot;std&quot;, derive(::ink_storage::traits::StorageLayout))]
#[derive(Debug, SpreadLayout)]
pub struct Data&lt;E&gt;
where
    E: Env,
{
    /// The owner of contract
    pub deposits: StorageHashMap&lt;E::AccountId, E::Balance&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages-for-txs-7"><a class="header" href="#messages-for-txs-7">Messages for Txs</a></h2>
<h3 id="deposit"><a class="header" href="#deposit">deposit</a></h3>
<p>Stores the sent amount as credit to be withdrawn.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Stores the sent amount as credit to be withdrawn.
    /// @param payee The destination address of the funds.
    fn deposit(&amp;mut self, payee: E::AccountId) {
        self.ensure_caller_is_owner();

        let amount = Self::transferred_balance();

        Storage::&lt;E, Data&lt;E&gt;&gt;::get_mut(self).add(&amp;payee, &amp;amount);

        self.emit_event_deposited(payee, amount);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="withdraw"><a class="header" href="#withdraw">withdraw</a></h3>
<p>Withdraw accumulated balance for a payee, forwarding all gas to the recipient.</p>
<blockquote>
<p>WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
Make sure you trust the recipient, or are either following the
checks-effects-interactions pattern or using {ReentrancyGuard}.</p>
</blockquote>
<p>param:</p>
<ul>
<li><code>payee</code> : The address whose funds will be withdrawn and transferred to.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// @dev Withdraw accumulated balance for a payee, forwarding all gas to the
    /// recipient.
    ///
    /// WARNING: Forwarding all gas opens the door to reentrancy vulnerabilities.
    /// Make sure you trust the recipient, or are either following the
    /// checks-effects-interactions pattern or using {ReentrancyGuard}.
    ///
    /// @param payee The address whose funds will be withdrawn and transferred to.
    fn withdraw(&amp;mut self, payee: E::AccountId) {
        self.ensure_caller_is_owner();

        let payment = Storage::&lt;E, Data&lt;E&gt;&gt;::get(self).get(&amp;payee);

        Storage::&lt;E, Data&lt;E&gt;&gt;::get_mut(self).clean(&amp;payee);

        let res = Self::transfer(payee.clone(), payment);
        assert!(res.is_ok(), &quot;Escrow: transfer to payee error&quot;);

        self.emit_event_withdrawn(payee, payment);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-7"><a class="header" href="#message-for-querys-7">Message for Querys</a></h2>
<h3 id="deposits_of"><a class="header" href="#deposits_of">deposits_of</a></h3>
<p>Return the deposits of payee</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Return the deposits of payee
    fn deposits_of(&amp;self, payee: &amp;E::AccountId) -&gt; E::Balance {
        Storage::&lt;E, Data&lt;E&gt;&gt;::get(self).get(payee)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-7"><a class="header" href="#events-7">Events</a></h2>
<h3 id="deposited"><a class="header" href="#deposited">Deposited</a></h3>
<p>Event emitted when payee deposit amount</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when payee deposit amount
    #[ink(event)]
    #[metis(escrow)]
    pub struct Deposited {
        #[ink(topic)]
        pub payee: AccountId,
        pub amount: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="withdrawn"><a class="header" href="#withdrawn">Withdrawn</a></h3>
<p>Event emitted when payee withdraw</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when payee withdraw
    #[ink(event)]
    #[metis(escrow)]
    pub struct Withdrawn {
        #[ink(topic)]
        pub payee: AccountId,
        pub amount: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>Contract component for security:</p>
<ul>
<li><a href="./security/pausable.html">Pausable</a></li>
<li><a href="./security/reentrancy-guard.html">Reentrancy Guard</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pausable"><a class="header" href="#pausable">Pausable</a></h1>
<p>Contract component which allows children to implement an emergency stop
mechanism that can be triggered by an authorized account.</p>
<p>This component is used through inheritance. It will make available the
api <code>ensure_not_paused</code> and <code>ensure_paused</code>, which can be applied to
the functions of your contract. Note that they will not be pausable by
simply including this component, only once the modifiers are put in place.</p>
<h2 id="usage-9"><a class="header" href="#usage-9">Usage</a></h2>
<p>To use <code>Pausable</code> component, should import pausable, at the same time, if use pausable component,
we need some access control to control pause or unpause, so we will also import ownerable component.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
mod contract {
    use metis_lang::{
        import,
        metis,
    };
    
    use metis_ownable as ownable;
    use metis_pausable as pausable;

    #[ink(storage)]
    #[import(pausable, ownable)]
    pub struct PausableContract {
        pausable: pausable::Data,
        ownable: ownable::Data&lt;Flipper&gt;,

        // other datas
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note pausable component not need use Env for types in environment, just use <code>pausable::Data</code>.</p>
<p>Add Events which pausable need:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when Pause
    #[ink(event)]
    #[metis(pausable)]
    pub struct Paused {
        /// paused caller
        #[ink(topic)]
        account: AccountId,
    }

    /// Event emitted when unPause
    #[ink(event)]
    #[metis(pausable)]
    pub struct Unpaused {
        /// unpaused caller
        #[ink(topic)]
        account: AccountId,
    }

    /// Need OwnershipTransferred for ownerable.
<span class="boring">}
</span></code></pre></pre>
<p>in constructor, call the init from pausable:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[ink(constructor)]
    pub fn new() -&gt; Self {
        let mut instance = Self {
            pausable: pausable::Data::default(),
            ownable: ownable::Data::default(),

            // other datas default data
        };

        pausable::Impl::init(&amp;mut instance);
        ownable::Impl::init(&amp;mut instance);

        // other initializes

        instance
    }
<span class="boring">}
</span></code></pre></pre>
<p>then add the message to control if is paused:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns true if the contract is paused, and false otherwise
    #[ink(message)]
    pub fn paused(&amp;self) -&gt; bool {
        pausable::Impl::paused(self)
    }

    /// Pause the contract, will emit the `Paused` Event
    ///
    /// Requirements:
    ///
    /// - The contract must be not paused.
    /// - The caller should be the owner of contract
    #[ink(message)]
    pub fn pause(&amp;mut self) {
        ownable::Impl::ensure_caller_is_owner(self);
        pausable::Impl::_pause(self)
    }

    /// Unpause the contract, will emit the `Unpaused` Event
    ///
    /// Requirements:
    ///
    /// - The contract must be paused.
    /// - The caller should be the owner of contract
    #[ink(message)]
    pub fn unpause(&amp;mut self) {
        ownable::Impl::ensure_caller_is_owner(self);
        pausable::Impl::_unpause(self)
    }
<span class="boring">}
</span></code></pre></pre>
<p>In this example, only owner can pause or unpause the contract. In different contracts, this also can impl by access-control component.</p>
<p>In other contract messages, we can use <code>ensure_paused</code> and <code>ensure_not_paused</code> to control contract logic by paused:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[ink(message)]
    pub fn do_sth(&amp;mut self) {
        // if contract is paused, the do_sth cannot called
        pausable::Impl::ensure_not_paused(self);
        
        // logic for do_sth
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="module-4"><a class="header" href="#module-4">Module</a></h2>
<p><code>Pausable</code> has only one state for pause or unpause:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The Data of pausable component
#[cfg_attr(feature = &quot;std&quot;, derive(::ink_storage::traits::StorageLayout))]
#[derive(Debug, SpreadLayout)]
pub struct Data {
    /// is contract current paused
    paused: Lazy&lt;bool&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="messages-for-txs-8"><a class="header" href="#messages-for-txs-8">Messages for Txs</a></h2>
<p>To control a contract is paused or unpause, we need impl some access limit for it, so the <code>_pause</code> and <code>_unpause</code> should call by develop.</p>
<blockquote>
<p><strong>WARNNING</strong> NOT use <code>_pause</code> and <code>_unpause</code> directly.</p>
</blockquote>
<h3 id="_pause"><a class="header" href="#_pause">_pause</a></h3>
<p>Pause the contract, will emit the Paused Event.</p>
<p>Requirements:</p>
<ul>
<li>The contract must be not paused.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Pause the contract, will emit the Paused Event
    ///
    /// Requirements:
    ///
    /// - The contract must be not paused.
    fn _pause(&amp;mut self) {
        self.ensure_not_paused();
        self.get_mut().pause();
        self.emit_event_paused(Self::caller());
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_unpause"><a class="header" href="#_unpause">_unpause</a></h3>
<p>Unpause the contract, will emit the <code>Unpaused</code> Event</p>
<p>Requirements:</p>
<ul>
<li>The contract must be paused.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Unpause the contract, will emit the `Unpaused` Event
    ///
    /// Requirements:
    ///
    /// - The contract must be paused.
    fn _unpause(&amp;mut self) {
        self.ensure_paused();
        self.get_mut().unpause();
        self.emit_event_unpaused(Self::caller());
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys-8"><a class="header" href="#message-for-querys-8">Message for Querys</a></h2>
<h3 id="paused"><a class="header" href="#paused">paused</a></h3>
<p>Returns true if the contract is paused, and false otherwise</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns true if the contract is paused, and false otherwise
    fn paused(&amp;self) -&gt; bool {
        self.get().is_paused()
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-7"><a class="header" href="#apis-7">APIs</a></h2>
<p>A contract with <code>Pausable</code> component can use <code>ensure_paused</code> and <code>ensure_not_paused</code> to make sure the messages cannot used when paused.</p>
<h3 id="ensure_paused"><a class="header" href="#ensure_paused">ensure_paused</a></h3>
<p>Panic if current is not paused.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic if current is not paused.
    fn ensure_paused(&amp;self) {
        assert!(self.get().is_paused(), &quot;Pausable: ensure paused&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="ensure_not_paused"><a class="header" href="#ensure_not_paused">ensure_not_paused</a></h3>
<p>Panic if current is paused.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Panic if current is paused.
    fn ensure_not_paused(&amp;self) {
        assert!(!self.get().is_paused(), &quot;Pausable: ensure not paused&quot;);
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events-8"><a class="header" href="#events-8">Events</a></h2>
<h3 id="paused-1"><a class="header" href="#paused-1">Paused</a></h3>
<p>The Event will emit when the contract is into paused state.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when Pause
    #[ink(event)]
    #[metis(pausable)]
    pub struct Paused {
        /// paused caller
        #[ink(topic)]
        account: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="unpaused"><a class="header" href="#unpaused">Unpaused</a></h3>
<p>The Event will emit when the contract is unpaused.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when unPause
    #[ink(event)]
    #[metis(pausable)]
    pub struct Unpaused {
        /// unpaused caller
        #[ink(topic)]
        account: AccountId,
    }
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reentrancy-guard"><a class="header" href="#reentrancy-guard">Reentrancy Guard</a></h1>
<p>Contract component that helps prevent reentrant calls to a function.</p>
<h2 id="usage-10"><a class="header" href="#usage-10">Usage</a></h2>
<p>To use <code>reentrant_guard</code> component, first is import the component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    use metis_lang::{
        import,
        metis,
    };
    
    use metis_reentrancy_guard as reentrancy_guard;

    #[ink(storage)]
    #[import(reentrancy_guard)]
    pub struct Contracts {
        reentrancy_guard: reentrancy_guard::Data,

        // others
    }
<span class="boring">}
</span></code></pre></pre>
<p>To use reentrancy guard, we can use a marco to check, it like the modifier in solidity:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[ink(message)]
        #[metis_lang::reentrancy_guard]
        pub fn function_can_not_reentrancy(&amp;mut self) {
            // logics
        }
<span class="boring">}
</span></code></pre></pre>
<h2 id="module-5"><a class="header" href="#module-5">Module</a></h2>
<p>In most cases, developer not need to consider the module of reentrancy guard.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const _NOT_ENTERED: u8 = 1;
const _ENTERED: u8 = 2;

/// The Data of pausable component
#[cfg_attr(feature = &quot;std&quot;, derive(::ink_storage::traits::StorageLayout))]
#[derive(Debug)]
pub struct Data {
    /// is contract current paused
    status: Lazy&lt;u8&gt;,

    key: ink_primitives::Key,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note the <code>key</code> in module, in <code>ink!</code>, all storage will flush to storage after the end of message proccess,
so if just to use <code>status</code>, the reentrancy_guard will not work:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// set current status to entered
    pub fn set_entered(&amp;mut self) {
        Lazy::set(&amp;mut self.status, _ENTERED);
        self.flush() // flush to storage
    }

    /// set current status to not entered
    pub fn set_not_entered(&amp;mut self) {
        Lazy::set(&amp;mut self.status, _NOT_ENTERED);
        self.flush() // flush to storage
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis-8"><a class="header" href="#apis-8">APIs</a></h2>
<p>There is some api for reentrancy_guard, the marco do this works:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        #[ink(message)]
        #[metis_lang::reentrancy_guard]
        pub fn function_can_not_reentrancy(&amp;mut self) {
            self._check_nonreentrant();
            self._set_entered();

            // logics

            self._set_not_entered();
        }
<span class="boring">}
</span></code></pre></pre>
<p>the apis :</p>
<ul>
<li><code>_check_nonreentrant</code> : is_entered is current is paused</li>
<li><code>_set_entered</code> : set current status to entered</li>
<li><code>_set_not_entered</code> : set current status to not entered</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools"><a class="header" href="#tools">Tools</a></h1>
<p>Tools components for creating contract, some components is just a marco for general codes.</p>
<ul>
<li><a href="./tools/erc165.html">ERC165</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="erc165"><a class="header" href="#erc165">ERC165</a></h1>
<p>Component help Contract to creates a standard method to publish and detect what interfaces a smart contract implements.</p>
<p>The details of the ERC165 can see <a href="https://eips.ethereum.org/EIPS/eip-165">ERC165</a>.</p>
<p>In <code>ink!</code>, the message interface id is same to EVM, so we make a marco to help develop to impl the erc165.</p>
<p>For example, a contract like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Flipper {
        /// Creates a new flipper smart contract initialized with the given value.
        #[ink(constructor)]
        pub fn new(init_value: bool) -&gt; Self {
            Self { value: init_value }
        }

        /// Creates a new flipper smart contract initialized to `false`.
        #[ink(constructor)]
        pub fn default() -&gt; Self {
            Self::new(Default::default())
        }

        /// Flips the current value of the Flipper's bool.
        #[ink(message)]
        pub fn flip(&amp;mut self) {
            // logics
        }

        /// Flips set the current value
        #[ink(message)]
        pub fn set(&amp;mut self, value: bool) {
            // logics
        }

        /// Returns the current value of the Flipper's bool.
        #[ink(message)]
        pub fn get(&amp;self) -&gt; bool {
            // logics
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>We can define a interface contains <code>get</code> and <code>set</code> message, so the <code>supports_interface</code> should be:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        impl Flipper {
            fn supports_interface(&amp;self, interface_id: u32) -&gt; bool {
                match interface_id {
                    0x633aa551_u32 ^ 0x2f865bd9_u32 =&gt; true, // get and set
                    0xe6113a8a_u32 =&gt; true, // supports_interface
                    _ =&gt; false,
                }
            }
        }
<span class="boring">}
</span></code></pre></pre>
<p>Note if impl <code>supports_interface</code> then also support the interface of erc165 self, so the <code>0xe6113a8a_u32</code> should also true.</p>
<p>The erc165 marco help us to impl the <code>supports_interface</code> message:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[metis::supports(interface(new, default), interface(flip, get))]
    impl Flipper {
        /// Return the contract is support the interface_id
        #[ink(message)]
        pub fn supports_interface(&amp;self, interface_id: u32) -&gt; bool {
            // _supports_interface gen by marco
            self._supports_interface(interface_id)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>Note last codes, it equal to this code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Flipper {
        fn _supports_interface(&amp;self, interface_id: u32) -&gt; bool {
            const INIT_INTERFACE_ID: u32 = 0x9bae9d5e_u32 ^ 0xed4b9d1b_u32;
            const FLIP_INTERFACE_ID: u32 = 0x633aa551_u32 ^ 0x2f865bd9_u32;

            match interface_id {
                INIT_INTERFACE_ID =&gt; true, // new and default
                FLIP_INTERFACE_ID =&gt; true, // flip get
                0xe6113a8a_u32 =&gt; true, // supports_interface
                _ =&gt; false,
            }
        }

        /// Return the contract is support the interface_id
        #[ink(message)]
        pub fn supports_interface(&amp;self, interface_id: u32) -&gt; bool {
            self._supports_interface(interface_id)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>The marco will not make <code>supports_interface</code> but general <code>_supports_interface</code> for developer to impl <code>supports_interface</code>.</p>
<p>The marco is like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[metis::supports(interface(new, default), interface(flip, get))]
    impl Flipper {}
<span class="boring">}
</span></code></pre></pre>
<p>For a contract, it will support multi interfaces, so there is a array of interfaces, which contains the message name need.</p>
<blockquote>
<p>Note: if use marco, the contract will support the <code>supports_interface</code> interface(0xe6113a8a_u32) auto.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
