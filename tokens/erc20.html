<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ERC20 - The Documentation of Metis</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="../favicon.svg">
                        <link rel="shortcut icon" href="../favicon.png">
                <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
                <link rel="stylesheet" href="../css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="../fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../use-component.html"><strong aria-hidden="true">2.</strong> Use Component</a></li><li class="chapter-item expanded "><a href="../access-control.html"><strong aria-hidden="true">3.</strong> Access Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../access-control/ownable.html"><strong aria-hidden="true">3.1.</strong> Ownable</a></li><li class="chapter-item expanded "><a href="../access-control/access-control.html"><strong aria-hidden="true">3.2.</strong> Access Control</a></li><li class="chapter-item expanded "><a href="../access-control/access-control-enumerable.html"><strong aria-hidden="true">3.3.</strong> Access Control Enumerable</a></li></ol></li><li class="chapter-item expanded "><a href="../governance.html"><strong aria-hidden="true">4.</strong> Governance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../governance/timelock-controller.html"><strong aria-hidden="true">4.1.</strong> Timelock Controller</a></li></ol></li><li class="chapter-item expanded "><a href="../tokens.html"><strong aria-hidden="true">5.</strong> Tokens</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tokens/erc20.html" class="active"><strong aria-hidden="true">5.1.</strong> ERC20</a></li><li class="chapter-item expanded "><a href="../tokens/erc721.html"><strong aria-hidden="true">5.2.</strong> ERC721</a></li><li class="chapter-item expanded "><a href="../tokens/erc777.html"><strong aria-hidden="true">5.3.</strong> ERC777</a></li><li class="chapter-item expanded "><a href="../tokens/erc1155.html"><strong aria-hidden="true">5.4.</strong> ERC1155</a></li></ol></li><li class="chapter-item expanded "><a href="../utilities.html"><strong aria-hidden="true">6.</strong> Utilities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../utilities/escrow.html"><strong aria-hidden="true">6.1.</strong> Escrow</a></li></ol></li><li class="chapter-item expanded "><a href="../security.html"><strong aria-hidden="true">7.</strong> Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../security/pausable.html"><strong aria-hidden="true">7.1.</strong> Pausable</a></li><li class="chapter-item expanded "><a href="../security/reentrancy-guard.html"><strong aria-hidden="true">7.2.</strong> Reentrancy Guard</a></li></ol></li><li class="chapter-item expanded "><a href="../tools.html"><strong aria-hidden="true">8.</strong> Tools</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tools/erc165.html"><strong aria-hidden="true">8.1.</strong> ERC165</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">The Documentation of Metis</h1>

                    <div class="right-buttons">
                                                <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="erc20"><a class="header" href="#erc20">ERC20</a></h1>
<p>Details of ERC20 can be found in <a href="https://eips.ethereum.org/EIPS/eip-20">ERC20</a>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To make a new erc20-like token, we should import erc20 at first:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[metis_lang::contract]
pub mod contract {
    // use Error and Result for erc20
    pub use erc20::{
        Error,
        Result,
    };

    // use erc20 component
    use metis_erc20 as erc20;
    use metis_lang::{
        import,
        metis,
    };

    /// ERC-20 contract.
    #[ink(storage)]
    #[import(erc20)]
    pub struct Erc20 {
        erc20: erc20::Data&lt;Erc20&gt;,
    }

    // other logics
}
<span class="boring">}
</span></code></pre></pre>
<p>Then add the event for erc20:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub value: Balance,
    }

    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the component:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    #[cfg(not(feature = &quot;ink-as-dependency&quot;))]
    impl erc20::Impl&lt;Erc20&gt; for Erc20 {
        /// Hook that is called before any transfer of tokens. This includes
        /// minting and burning.
        ///
        /// Calling conditions:
        ///
        /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
        /// will be to transferred to `to`.
        /// - when `from` is zero, `amount` tokens will be minted for `to`.
        /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.
        /// - `from` and `to` are never both zero.
        fn _before_token_transfer(
            &amp;mut self,
            _from: &amp;E::AccountId,
            _to: &amp;E::AccountId,
            _amount: E::Balance,
        ) -&gt; Result&lt;()&gt;{
            // some logic

            Ok(())
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>impl the constructor for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Erc20 {
    /// the constructor of the contract
    #[ink(constructor)]
    pub fn new(
        name: String,
        symbol: String,
        decimals: u8,
        initial_supply: Balance,
    ) -&gt; Self {
        let mut instance = Self {
            erc20: erc20::Data::new(),
        };

        erc20::Impl::init(&amp;mut instance, name, symbol, decimals, initial_supply);

        // do some other logic here

        instance
    }
  }
<span class="boring">}
</span></code></pre></pre>
<p>Then implement the messages for contract:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    impl Erc20 {
        /// Returns the name of the token.
        #[ink(message)]
        pub fn name(&amp;self) -&gt; String {
            erc20::Impl::name(self)
        }

        /// Returns the symbol of the token,
        /// usually a shorter version of the name.
        #[ink(message)]
        pub fn symbol(&amp;self) -&gt; String {
            erc20::Impl::symbol(self)
        }

        /// Returns the number of decimals used to
        /// get its user representation.
        /// For example, if `decimals` equals `2`,
        /// a balance of `505` tokens should
        /// be displayed to a user as `5,05` (`505 / 10 ** 2`).
        ///
        /// Tokens usually opt for a value of 18,
        /// imitating the relationship between
        /// Ether and Wei in ETH. This is the value {ERC20} uses,
        /// unless this function is
        /// overridden;
        ///
        /// NOTE: This information is only used for _display_ purposes:
        /// it in no way affects any of the arithmetic of the contract
        #[ink(message)]
        pub fn decimals(&amp;self) -&gt; u8 {
            erc20::Impl::decimals(self)
        }

        /// Returns the amount of tokens in existence.
        #[ink(message)]
        pub fn total_supply(&amp;self) -&gt; Balance {
            erc20::Impl::total_supply(self)
        }

        /// Returns the amount of tokens owned by `account`.
        #[ink(message)]
        pub fn balance_of(&amp;self, owner: AccountId) -&gt; Balance {
            erc20::Impl::balance_of(self, &amp;owner)
        }

        /// Returns the remaining number of tokens that `spender` will be
        /// allowed to spend on behalf of `owner` through {transferFrom}. This is
        /// zero by default.
        ///
        /// This value changes when {approve} or {transferFrom} are called.
        #[ink(message)]
        pub fn allowance(&amp;self, owner: AccountId, spender: AccountId) -&gt; Balance {
            erc20::Impl::allowance(self, &amp;owner, &amp;spender)
        }

        /// Moves `amount` tokens from the caller's account to `recipient`.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn transfer(&amp;mut self, to: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc20::Impl::transfer(self, &amp;to, value)
        }

        /// Sets `amount` as the allowance of `spender` over the caller's tokens.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// IMPORTANT: Beware that changing an allowance with this method brings
        /// the risk that someone may use both the old and the new allowance
        /// by unfortunate transaction ordering. One possible solution to 
        /// mitigate this race condition is to first reduce the spender's 
        /// allowance to 0 and set the desired value afterwards:
        /// &lt;https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&gt;
        ///
        /// Emits an {Approval} event.
        #[ink(message)]
        pub fn approve(&amp;mut self, spender: AccountId, value: Balance) -&gt; Result&lt;()&gt; {
            erc20::Impl::approve(self, &amp;spender, value)
        }

        /// Moves `amount` tokens from `sender` to `recipient` using the
        /// allowance mechanism. `amount` is then deducted from the caller's
        /// allowance.
        ///
        /// Returns a boolean value indicating whether the operation succeeded.
        ///
        /// Emits a {Transfer} event.
        #[ink(message)]
        pub fn transfer_from(
            &amp;mut self,
            from: AccountId,
            to: AccountId,
            value: Balance,
        ) -&gt; Result&lt;()&gt; {
            erc20::Impl::transfer_from(self, &amp;from, &amp;to, value)
        }
    }
<span class="boring">}
</span></code></pre></pre>
<p>In the end, we can add some other messages.</p>
<h2 id="messages-for-txs"><a class="header" href="#messages-for-txs">Messages for Txs</a></h2>
<h3 id="transfer"><a class="header" href="#transfer">transfer</a></h3>
<p>Moves <code>amount</code> tokens from the caller's account to <code>recipient</code>.</p>
<p>Returns a Result indicating whether the operation succeeded.</p>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from the caller's account to `recipient`.
    ///
    /// Returns a Result indicating whether the operation succeeded.
    ///
    /// Emits a `Transfer` event.
    fn transfer(&amp;mut self, to: &amp;E::AccountId, value: E::Balance) -&gt; Result&lt;()&gt; {
        self._transfer_from_to(&amp;Self::caller(), to, value)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approve"><a class="header" href="#approve">approve</a></h3>
<p>Sets <code>amount</code> as the allowance of <code>spender</code> over the caller's tokens.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>IMPORTANT: Beware that changing an allowance with this method brings the risk
that someone may use both the old and the new allowance by unfortunate
transaction ordering. One possible solution to mitigate this race
condition is to first reduce the spender's allowance to 0 and set the
desired value afterwards:
<a href="https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729">https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</a></p>
<p>Emits an <code>Approval</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Sets `amount` as the allowance of `spender` over the caller's tokens.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// IMPORTANT: Beware that changing an allowance with this method brings the risk
    /// that someone may use both the old and the new allowance by unfortunate
    /// transaction ordering. One possible solution to mitigate this race
    /// condition is to first reduce the spender's allowance to 0 and set the
    /// desired value afterwards:
    /// &lt;https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729&gt;
    ///
    /// Emits an `Approval` event.
    fn approve(&amp;mut self, spender: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        self._approve(&amp;Self::caller(), spender, amount)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="transfer_from"><a class="header" href="#transfer_from">transfer_from</a></h3>
<p>Moves <code>amount</code> tokens from <code>sender</code> to <code>recipient</code> using the
allowance mechanism. <code>amount</code> is then deducted from the caller's
allowance.</p>
<p>Returns a boolean value indicating whether the operation succeeded.</p>
<p>Emits a <code>Transfer</code> event.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves `amount` tokens from `sender` to `recipient` using the
    /// allowance mechanism. `amount` is then deducted from the caller's
    /// allowance.
    ///
    /// Returns a boolean value indicating whether the operation succeeded.
    ///
    /// Emits a `Transfer` event.
    fn transfer_from(
        &amp;mut self,
        from: &amp;E::AccountId,
        to: &amp;E::AccountId,
        amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        let caller = &amp;Self::caller();

        let current_allowance = self.get().allowance(from, caller);
        if current_allowance &lt; amount {
            return Err(Error::InsufficientAllowance)
        }

        self._transfer_from_to(from, to, amount)?;

        self._approve(from, caller, current_allowance - amount)?;

        Ok(())
    }

<span class="boring">}
</span></code></pre></pre>
<h2 id="message-for-querys"><a class="header" href="#message-for-querys">Message for Querys</a></h2>
<h3 id="name"><a class="header" href="#name">name</a></h3>
<p>Returns the name of the token.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the name of the token.
    fn name(&amp;self) -&gt; String {
        self.get().name().clone()
    }

<span class="boring">}
</span></code></pre></pre>
<h3 id="symbol"><a class="header" href="#symbol">symbol</a></h3>
<p>Returns the symbol of the token, usually a shorter version of the name.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the symbol of the token, usually a shorter version of the name.
    fn symbol(&amp;self) -&gt; String {
        self.get().symbol().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="decimals"><a class="header" href="#decimals">decimals</a></h3>
<p>Returns the number of decimals used to get its user representation.
For example, if <code>decimals</code> equals <code>2</code>, a balance of <code>505</code> tokens should
be displayed to a user as <code>5,05</code> (<code>505 / 10 ** 2</code>).</p>
<p>Tokens usually opt for a value of 18, imitating the relationship between
Ether and Wei in ETH. This is the value {ERC20} uses, unless this function is
overridden;</p>
<blockquote>
<p>NOTE: This information is only used for <em>display</em> purposes: it in
no way affects any of the arithmetic of the contract</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the number of decimals used to get its user representation.
    /// For example, if `decimals` equals `2`, a balance of `505` tokens should
    /// be displayed to a user as `5,05` (`505 / 10 ** 2`).
    ///
    /// Tokens usually opt for a value of 18, imitating the relationship between
    /// Ether and Wei in ETH. This is the value {ERC20} uses, unless this function is
    /// overridden;
    ///
    /// NOTE: This information is only used for _display_ purposes: it in
    /// no way affects any of the arithmetic of the contract
    fn decimals(&amp;self) -&gt; u8 {
        self.get().decimals().clone()
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="balance_of"><a class="header" href="#balance_of">balance_of</a></h3>
<p>Returns the amount of tokens owned by <code>account</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens owned by `account`.
    fn balance_of(&amp;self, account: &amp;E::AccountId) -&gt; E::Balance {
        self.get().balance_of(account)
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="total_supply"><a class="header" href="#total_supply">total_supply</a></h3>
<p>Returns the amount of tokens in existence.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the amount of tokens in existence.
    fn total_supply(&amp;self) -&gt; E::Balance {
        self.get().total_supply()
    }

<span class="boring">}
</span></code></pre></pre>
<h3 id="allowance"><a class="header" href="#allowance">allowance</a></h3>
<p>Returns the remaining number of tokens that <code>spender</code> will be
allowed to spend on behalf of <code>owner</code> through <code>transfer_from</code>. This is
zero by default.</p>
<p>This value changes when <code>approve</code> or <code>transfer_from</code> are called.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Returns the remaining number of tokens that `spender` will be
    /// allowed to spend on behalf of `owner` through `transfer_from`. This is
    /// zero by default.
    ///
    /// This value changes when `approve` or `transfer_from` are called.
    fn allowance(&amp;self, owner: &amp;E::AccountId, spender: &amp;E::AccountId) -&gt; E::Balance {
        self.get().allowance(owner, spender)
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="apis"><a class="header" href="#apis">APIs</a></h2>
<p>If the contract need make some logic by token, developers can based on this apis:</p>
<ul>
<li><code>_mint</code> : mint token to a account with amount</li>
<li><code>_burn</code> : burn token from a account by amount</li>
<li><code>_transfer_from_to</code> : move token from a account to another</li>
</ul>
<h3 id="_mint"><a class="header" href="#_mint">_mint</a></h3>
<p>Creates <code>amount</code> tokens and assigns them to <code>account</code>, increasing
the total supply.</p>
<p>Emits a <code>Transfer</code> event with <code>from</code> set to the zero address.</p>
<p>Requirements:</p>
<ul>
<li><code>account</code> cannot be the zero address.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Creates `amount` tokens and assigns them to `account`, increasing
    /// the total supply.
    ///
    /// Emits a `Transfer` event with `from` set to the zero address.
    ///
    /// Requirements:
    ///
    /// - `account` cannot be the zero address.
    fn _mint(&amp;mut self, account: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();
        if account == null_account {
            return Err(Error::AccountIsZero)
        }

        self._before_token_transfer(null_account, account, amount)?;

        let total_supply = self.get().total_supply();
        let account_balance = self.get().balance_of(account);

        self.get_mut().set_total_supply(total_supply + amount);
        self.get_mut()
            .set_balance(account, account_balance + amount);

        self.emit_event_transfer(None, Some(account.clone()), amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_burn"><a class="header" href="#_burn">_burn</a></h3>
<p>Destroys <code>amount</code> tokens from <code>account</code>, reducing the total supply.</p>
<p>Emits a <code>Transfer</code> event with <code>to</code> set to the None address.</p>
<p>Requirements:</p>
<ul>
<li><code>account</code> must have at least <code>amount</code> tokens.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Destroys `amount` tokens from `account`, reducing the
    /// total supply.
    ///
    /// Emits a `Transfer` event with `to` set to the None address.
    ///
    /// Requirements:
    ///
    /// - `account` must have at least `amount` tokens.
    fn _burn(&amp;mut self, account: &amp;E::AccountId, amount: E::Balance) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();

        if account == &amp;E::AccountId::default() {
            return Err(Error::AccountIsZero)
        }

        self._before_token_transfer(account, null_account, amount)?;

        let account_balance = self.get().balance_of(account);
        let total_supply = self.get().total_supply();

        if account_balance &lt; amount {
            return Err(Error::InsufficientBalance)
        }

        self.get_mut()
            .set_balance(account, account_balance - amount);
        self.get_mut().set_total_supply(total_supply - amount);

        self.emit_event_transfer(Some(account.clone()), None, amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="_transfer_from_to"><a class="header" href="#_transfer_from_to">_transfer_from_to</a></h3>
<p>Moves tokens <code>amount</code> from <code>sender</code> to <code>recipient</code>.</p>
<p>This is internal function is equivalent to <code>transfer</code>, and can be used to</p>
<p>e.g. implement automatic token fees, slashing mechanisms, etc.
Emits a <code>Transfer</code> event.</p>
<p>Requirements:</p>
<ul>
<li><code>sender</code> cannot be the zero address.</li>
<li><code>recipient</code> cannot be the zero address.</li>
<li><code>sender</code> must have a balance of at least <code>amount</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Moves tokens `amount` from `sender` to `recipient`.
    ///
    /// This is internal function is equivalent to `transfer`, and can be used to
    /// e.g. implement automatic token fees, slashing mechanisms, etc.
    ///
    /// Emits a `Transfer` event.
    ///
    /// Requirements:
    ///
    /// - `sender` cannot be the zero address.
    /// - `recipient` cannot be the zero address.
    /// - `sender` must have a balance of at least `amount`.
    fn _transfer_from_to(
        &amp;mut self,
        sender: &amp;E::AccountId,
        recipient: &amp;E::AccountId,
        amount: E::Balance,
    ) -&gt; Result&lt;()&gt; {
        let null_account = &amp;E::AccountId::default();

        if sender == null_account || recipient == null_account {
            return Err(Error::AccountIsZero)
        }

        self._before_token_transfer(sender, recipient, amount)?;

        let sender_balance = self.get().balance_of(sender);
        if sender_balance &lt; amount {
            return Err(Error::InsufficientBalance)
        }

        self.get_mut().set_balance(sender, sender_balance - amount);
        let recipient_balance = self.get().balance_of(recipient);
        self.get_mut()
            .set_balance(recipient, recipient_balance + amount);

        self.emit_event_transfer(
            Some(sender.clone()),
            Some(recipient.clone()),
            amount);

        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="hooks"><a class="header" href="#hooks">Hooks</a></h2>
<h3 id="_before_token_transfer"><a class="header" href="#_before_token_transfer">_before_token_transfer</a></h3>
<p>Hook that is called before any transfer of tokens. This includes
minting and burning.</p>
<p>Calling conditions:</p>
<ul>
<li>when <code>from</code> and <code>to</code> are both non-zero, <code>amount</code> of <code>from</code>'s tokens
will be to transferred to <code>to</code>.</li>
<li>when <code>from</code> is zero, <code>amount</code> tokens will be minted for <code>to</code>.</li>
<li>when <code>to</code> is zero, <code>amount</code> of <code>from</code>'s tokens will be burned.</li>
<li><code>from</code> and <code>to</code> are never both zero.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Hook that is called before any transfer of tokens. This includes
    /// minting and burning.
    ///
    /// Calling conditions:
    ///
    /// - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
    /// will be to transferred to `to`.
    /// - when `from` is zero, `amount` tokens will be minted for `to`.
    /// - when `to` is zero, `amount` of ``from``'s tokens will be burned.
    /// - `from` and `to` are never both zero.
    fn _before_token_transfer(
        &amp;mut self,
        _from: &amp;E::AccountId,
        _to: &amp;E::AccountId,
        _amount: E::Balance,
    ) -&gt; Result&lt;()&gt;{
        Ok(())
    }
<span class="boring">}
</span></code></pre></pre>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<h3 id="transfer-1"><a class="header" href="#transfer-1">Transfer</a></h3>
<p>Event emitted when a token transfer occurs.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when a token transfer occurs.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Transfer {
        #[ink(topic)]
        pub from: Option&lt;AccountId&gt;,
        #[ink(topic)]
        pub to: Option&lt;AccountId&gt;,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>
<h3 id="approval"><a class="header" href="#approval">Approval</a></h3>
<p>Event emitted when an approval occurs that <code>spender</code> is allowed to withdraw up to the amount of <code>value</code> tokens from <code>owner</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /// Event emitted when an approval occurs that `spender` is allowed to withdraw
    /// up to the amount of `value` tokens from `owner`.
    #[ink(event)]
    #[metis(erc20)]
    pub struct Approval {
        #[ink(topic)]
        pub owner: AccountId,
        #[ink(topic)]
        pub spender: AccountId,
        pub value: Balance,
    }
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="../tokens.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="../tokens/erc721.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="../tokens.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="../tokens/erc721.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
